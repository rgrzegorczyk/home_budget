-- *********************************************************************
-- Update Database Script
-- *********************************************************************
-- Change Log: changelog/master.xml
-- Ran at: 16.09.21 11:56
-- Against: HOME_BUDGET@jdbc:oracle:thin:@rgprod_high
-- Liquibase version: 4.4.2
  /*
  SCRIPT WILL BE INSTALLED ONLY IF THERE IS NO DATABSAECHANGELOGTABLE AT YOUR SCHEMA!
  */
-- *********************************************************************

-- Create Database Lock Table
CREATE TABLE HOME_BUDGET.DATABASECHANGELOGLOCK (ID INTEGER NOT NULL, LOCKED NUMBER(1) NOT NULL, LOCKGRANTED TIMESTAMP, LOCKEDBY VARCHAR2(255), CONSTRAINT PK_DATABASECHANGELOGLOCK PRIMARY KEY (ID));

-- Initialize Database Lock Table
DELETE FROM HOME_BUDGET.DATABASECHANGELOGLOCK;

INSERT INTO HOME_BUDGET.DATABASECHANGELOGLOCK (ID, LOCKED) VALUES (1, 0);

-- Lock Database
UPDATE HOME_BUDGET.DATABASECHANGELOGLOCK SET LOCKED = 1, LOCKEDBY = 'DESKTOP-H61VFP7 (10.195.20.235)', LOCKGRANTED = TO_TIMESTAMP('2021-09-16 11:56:33.345', 'YYYY-MM-DD HH24:MI:SS.FF') WHERE ID = 1 AND LOCKED = 0;

-- Create Database Change Log Table
CREATE TABLE HOME_BUDGET.DATABASECHANGELOG (ID VARCHAR2(255) NOT NULL, AUTHOR VARCHAR2(255) NOT NULL, FILENAME VARCHAR2(255) NOT NULL, DATEEXECUTED TIMESTAMP NOT NULL, ORDEREXECUTED INTEGER NOT NULL, EXECTYPE VARCHAR2(10) NOT NULL, MD5SUM VARCHAR2(35), DESCRIPTION VARCHAR2(255), COMMENTS VARCHAR2(255), TAG VARCHAR2(255), LIQUIBASE VARCHAR2(20), CONTEXTS VARCHAR2(255), LABELS VARCHAR2(255), DEPLOYMENT_ID VARCHAR2(10));

-- Changeset database/table/expense_groups.sql::expense_groups::RGRZEGORCZYK
-- expense_groups table
create table expense_groups (
    id                             number generated by default on null as identity start with 500
                                   constraint expense_groups_id_pk primary key,
    name                           varchar2(255),
    comments                       varchar2(4000),
    created                        date not null,
    created_by                     varchar2(255) not null,
    updated                        date not null,
    updated_by                     varchar2(255) not null
);

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expense_groups', 'RGRZEGORCZYK', 'database/table/expense_groups.sql', SYSTIMESTAMP, 1, '8:077d3cce19536b60c93b8aad8304e3b8', 'sql', 'expense_groups table', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/table/expense_types.sql::expense_types::RGRZEGORCZYK
-- expense_types table
create table expense_types (
    id                             number generated by default on null as identity  start with 500
                                   constraint expense_types_id_pk primary key,
    name                           varchar2(255),
    comments                       varchar2(4000),
    created                        date not null,
    created_by                     varchar2(255) not null,
    updated                        date not null,
    updated_by                     varchar2(255) not null,
    expense_group_id               number,
    display_order                  number
);

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expense_types', 'RGRZEGORCZYK', 'database/table/expense_types.sql', SYSTIMESTAMP, 2, '8:1442d18a612f5033f4cf9e85277dfc2c', 'sql', 'expense_types table', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/table/expenses.sql::expenses::RGRZEGORCZYK
-- Expenses table
create table expenses (
    id                             number generated by default on null as identity  start with 500
                                   constraint expenses_id_pk primary key,
    expense_types_id               number,      
    expense_date                   date,
    value                          number,
    quantity                       number (8,2),
    unit_price                     number (16,2),        
    is_returned                    char(1) default 'N',
    return_wire_received           char(1) default 'N',    
    return_value                   number(16,2),         
    comments                       varchar2(4000),
    created                        date not null,
    created_by                     varchar2(255) not null,
    updated                        date not null,
    updated_by                     varchar2(255) not null
);

COMMENT ON COLUMN EXPENSES.QUANTITY IS 'Quantity';

COMMENT ON COLUMN EXPENSES.UNIT_PRICE IS 'Unit price';

COMMENT ON COLUMN EXPENSES.IS_RETURNED IS 'Goods returned Y/N';

COMMENT ON COLUMN EXPENSES.RETURN_WIRE_RECEIVED IS 'Wire transfer received Y/N?';

COMMENT ON COLUMN EXPENSES.RETURN_VALUE IS 'Value of returned goods';

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expenses', 'RGRZEGORCZYK', 'database/table/expenses.sql', SYSTIMESTAMP, 3, '8:b9690dec1254e8eca6cf3d8afd4a8159', 'sql', 'Expenses table', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/table/expenses.sql::expenses_drop_cols::RGRZEGORCZYK
-- I don't need this columns anymore
ALTER TABLE EXPENSES DROP  (QUANTITY ,UNIT_PRICE );

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expenses_drop_cols', 'RGRZEGORCZYK', 'database/table/expenses.sql', SYSTIMESTAMP, 4, '8:be772bf3fe745c7ca3d138942acaed9c', 'sql', 'I don''t need this columns anymore', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/table/expenses.sql::expenses_add_cols::RGRZEGORCZYK
-- I need a place for shop name, order number, return details
ALTER TABLE EXPENSES ADD (SHOP_NAME VARCHAR2(100 CHAR),
                         ORDER_NUMBER VARCHAR2(255 CHAR),
                         RETURN_DETAILS VARCHAR2(255 CHAR) );

COMMENT ON COLUMN EXPENSES.SHOP_NAME IS 'Shop name, website or other preffered info';

COMMENT ON COLUMN EXPENSES.ORDER_NUMBER IS 'Order number';

COMMENT ON COLUMN EXPENSES.RETURN_DETAILS IS 'Return details if goods returned e.g return number, return parcel number etc.';

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expenses_add_cols', 'RGRZEGORCZYK', 'database/table/expenses.sql', SYSTIMESTAMP, 5, '8:9e6624bde508196134c0296646bb9a69', 'sql', 'I need a place for shop name, order number, return details', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/table/expenses_h.sql::expenses_h::RGRZEGORCZYK
-- Expenses_h audit table
create table EXPENSES_h
(
  hist_id number GENERATED BY DEFAULT ON NULL AS IDENTITY INCREMENT BY 1 START WITH 1 CACHE 20 NOT NULL,
  hist_op_type char(1 char) not null,
  hist_user varchar2(50 CHAR) not null,
  hist_op_ts timestamp(6) not null, 
  ID NUMBER not null, 
  EXPENSE_TYPES_ID NUMBER, 
  EXPENSE_DATE DATE, 
  VALUE NUMBER, 
  QUANTITY NUMBER (8,2),
  UNIT_PRICE NUMBER (16,2),
  IS_RETURNED CHAR(1) DEFAULT 'N',
  RETURN_WIRE_RECEIVED CHAR(1) DEFAULT 'N',
  RETURN_VALUE NUMBER (16,2),
  COMMENTS VARCHAR2(4000 char), 
  CREATED DATE, 
  CREATED_BY VARCHAR2(255 char), 
  UPDATED DATE, 
  UPDATED_BY VARCHAR2(255 char),
  CONSTRAINT EXPENSES_h_PK PRIMARY KEY (hist_id) ENABLE 
);

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expenses_h', 'RGRZEGORCZYK', 'database/table/expenses_h.sql', SYSTIMESTAMP, 6, '8:9ecd471202d36327615d8812cb4688dd', 'sql', 'Expenses_h audit table', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/table/periods_conf.sql::PERIODS_CONF::RGRZEGORCZYK
-- PERIODS_CONF table
CREATE TABLE PERIODS_CONF 
(	CODE VARCHAR2(100 CHAR), 
  NAME VARCHAR2(200 CHAR), 
  TYPE VARCHAR2(20 CHAR), 
  DATE_FROM DATE, 
  DATE_TO DATE
);

COMMENT ON COLUMN PERIODS_CONF.CODE IS 'Period code. Primary key';

COMMENT ON COLUMN PERIODS_CONF.NAME IS 'Period code name';

COMMENT ON COLUMN PERIODS_CONF.TYPE IS 'Type of period';

COMMENT ON COLUMN PERIODS_CONF.DATE_FROM IS 'Date from';

COMMENT ON COLUMN PERIODS_CONF.DATE_TO IS 'Date to';

COMMENT ON TABLE  PERIODS_CONF  IS 'Table with period codes';

CREATE UNIQUE INDEX PERIODS_PK ON PERIODS_CONF (CODE);

ALTER TABLE PERIODS_CONF MODIFY (CODE NOT NULL ENABLE);

ALTER TABLE PERIODS_CONF MODIFY (NAME NOT NULL ENABLE);

ALTER TABLE PERIODS_CONF MODIFY (TYPE NOT NULL ENABLE);

ALTER TABLE PERIODS_CONF MODIFY (DATE_FROM NOT NULL ENABLE);

ALTER TABLE PERIODS_CONF MODIFY (DATE_TO NOT NULL ENABLE);

ALTER TABLE PERIODS_CONF ADD CONSTRAINT PERIODS_PK PRIMARY KEY (CODE);

ALTER TABLE PERIODS_CONF ADD CONSTRAINT PERIODS_CONF_CHK1 CHECK (TYPE IN ('DAY', 'WEEK', 'MONTH', 'QUARTER', 'SEMI-YEAR', 'YEAR')) ENABLE;

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('PERIODS_CONF', 'RGRZEGORCZYK', 'database/table/periods_conf.sql', SYSTIMESTAMP, 7, '8:14e9c57f65986ed4b12b2a0b78de3aab', 'sql', 'PERIODS_CONF table', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/1_changelog_structure.xml::logger::RGRZEGORCZYK
-- This file contains the start and pre installation requirements for Logger
--addedd in line 4246 setting logger prefs to FALSE, and then again to TRUE
whenever sqlerror exit
set serveroutput on

-- SESSION PRIVILEGES
declare
    type t_sess_privs is table of pls_integer index by varchar2(50);
    l_sess_privs t_sess_privs;
    l_req_privs t_sess_privs;
    l_priv varchar2(50);
    l_dummy pls_integer;
    l_priv_error  boolean := false;
begin
    l_req_privs('CREATE SESSION')       := 1;            
    l_req_privs('CREATE TABLE')         := 1;
    l_req_privs('CREATE VIEW')          := 1;
    l_req_privs('CREATE SEQUENCE')      := 1;
    l_req_privs('CREATE PROCEDURE')     := 1;
    l_req_privs('CREATE TRIGGER')       := 1;
    l_req_privs('CREATE ANY CONTEXT')   := 1;
    l_req_privs('CREATE JOB')           := 1;


    for c1 in (select privilege from session_privs)
    loop
        l_sess_privs(c1.privilege) := 1;
    end loop;  --c1

    dbms_output.put_line('_____________________________________________________________________________');
    
    l_priv := l_req_privs.first;
    loop
    exit when l_priv is null;
        begin
            l_dummy := l_sess_privs(l_priv);
        exception when no_data_found then
            dbms_output.put_line('Error, the current schema is missing the following privilege: '||l_priv);
            l_priv_error := true;
        end;
        l_priv := l_req_privs.next(l_priv);
    end loop;
    
    if not l_priv_error then
        dbms_output.put_line('User has all required privileges, installation will continue.');
    end if;
    
    dbms_output.put_line('_____________________________________________________________________________');

    if l_priv_error then
      raise_application_error (-20000, 'One or more required privileges are missing.');
    end if;
end;
/

whenever sqlerror continue


PROMPT tables/logger_logs.sql 
-- Initial table script built from 1.4.0
declare
  l_count pls_integer;
  l_nullable user_tab_columns.nullable%type;

  type typ_required_columns is table of varchar2(30) index by pls_integer;
  l_required_columns typ_required_columns;


  type typ_tab_col is record (
    column_name varchar2(30),
    data_type varchar2(100));
  type typ_arr_tab_col is table of typ_tab_col index by pls_integer;

  l_new_col typ_tab_col;
  l_new_cols typ_arr_tab_col;

begin
  -- Create Table
  select count(1)
  into l_count
  from user_tables
  where table_name = 'LOGGER_LOGS';

  if l_count = 0 then
    execute immediate '
create table logger_logs(
  id number,
  logger_level number,
  text varchar2(4000),
  time_stamp timestamp,
  scope varchar2(1000),
  module varchar2(100),
  action varchar2(100),
  user_name varchar2(255),
  client_identifier varchar2(255),
  call_stack varchar2(4000),
  unit_name varchar2(255),
  line_no varchar2(100),
  scn number,
  extra clob,
  constraint logger_logs_pk primary key (id) enable,
  constraint logger_logs_lvl_ck check(logger_level in (1,2,4,8,16,32,64,128))
)
    ';
  end if;

  -- 2.0.0
  l_required_columns(l_required_columns.count+1) := 'LOGGER_LEVEL';
  l_required_columns(l_required_columns.count+1) := 'TIME_STAMP';

  for i in l_required_columns.first .. l_required_columns.last loop

    select nullable
    into l_nullable
    from user_tab_columns
    where table_name = 'LOGGER_LOGS'
      and column_name = upper(l_required_columns(i));

    if l_nullable = 'Y' then
      execute immediate 'alter table logger_logs modify ' || l_required_columns(i) || ' not null';
    end if;
  end loop;


  -- 2.2.0
  -- Add additional columns
  -- #51
  l_new_col.column_name := 'SID';
  l_new_col.data_type := 'NUMBER';
  l_new_cols(l_new_cols.count+1) := l_new_col;

  -- #25
  l_new_col.column_name := 'CLIENT_INFO';
  l_new_col.data_type := 'VARCHAR2(64)'; -- taken from v$session.client_info
  l_new_cols(l_new_cols.count+1) := l_new_col;


  for i in 1 .. l_new_cols.count loop
    select count(1)
    into l_count
    from user_tab_columns
    where 1=1
      and table_name = 'LOGGER_LOGS'
      and column_name = l_new_cols(i).column_name;

    if l_count = 0 then
      execute immediate 'alter table LOGGER_LOGS add (' || l_new_cols(i).column_name || ' ' || l_new_cols(i).data_type || ')';
    end if;
  end loop;


  $if $$logger_no_op_install $then
    null;
  $else
    -- SEQUENCE
    select count(1)
    into l_count
    from user_sequences
    where sequence_name = 'LOGGER_LOGS_SEQ';

    if l_count = 0 then
      execute immediate '
        create sequence logger_logs_seq
            minvalue 1
            maxvalue 999999999999999999999999999
            start with 1
            increment by 1
            cache 20
      ';
    end if;

    -- INDEXES
    select count(1)
    into l_count
    from user_indexes
    where index_name = 'LOGGER_LOGS_IDX1';

    if l_count = 0 then
      execute immediate 'create index logger_logs_idx1 on logger_logs(time_stamp,logger_level)';
    end if;
  $end

end;
/


-- TRIGGER (removed as part of 2.1.0 release)
-- Drop trigger if still exists (from pre-2.1.0 releases) - Issue #31
declare
  l_count pls_integer;
  l_trigger_name user_triggers.trigger_name%type := 'BI_LOGGER_LOGS';
begin
  select count(1)
  into l_count
  from user_triggers
  where 1=1
    and trigger_name = l_trigger_name;

  if l_count > 0 then
    execute immediate 'drop trigger ' || l_trigger_name;
  end if;
end;
/

PROMPT tables/logger_prefs.sql 
-- Initial table script built from 1.4.0
declare
  l_count pls_integer;
  l_nullable user_tab_columns.nullable%type;

  type typ_required_columns is table of varchar2(30) index by pls_integer;
  l_required_columns typ_required_columns;

begin
  -- Create Table
  select count(1)
  into l_count
  from user_tables
  where table_name = 'LOGGER_PREFS';

  if l_count = 0 then
    execute immediate '
create table logger_prefs(
  pref_name	varchar2(255),
  pref_value	varchar2(255) not null,
  constraint logger_prefs_pk primary key (pref_name) enable
)
    ';
  end if;

end;
/


-- TODO mdsouza: logger 3.1.1 fix. Removed currently_installing
-- Append existing PLSQL_CCFLAGS
-- Since may be set with existing flags (specifically no_op)
-- var cur_plsql_ccflags varchar2(500);
--
-- declare
--   parnam varchar2(256);
--   intval binary_integer;
--   strval varchar2(500);
--   partyp binary_integer;
-- begin
--   partyp := dbms_utility.get_parameter_value('plsql_ccflags',intval, strval);
--
--   if strval is not null then
--     strval := ',' || strval;
--   end if;
--   :cur_plsql_ccflags := strval;
-- end;
-- /
--
-- -- Convert bind variable to substitution string
-- -- https://blogs.oracle.com/opal/entry/sqlplus_101_substitution_varia
-- column cur_plsql_ccflags new_value cur_plsql_ccflags
-- select :cur_plsql_ccflags cur_plsql_ccflags from dual;
--
-- alter session set plsql_ccflags='currently_installing:true&cur_plsql_ccflags'
-- /

create or replace trigger biu_logger_prefs
  before insert or update on logger_prefs
  for each row
begin
  $if $$logger_no_op_install $then
    null;
  $else
    :new.pref_name := upper(:new.pref_name);
    :new.pref_type := upper(:new.pref_type);

    if 1=1
      and :new.pref_type = logger.g_pref_type_logger
      and :new.pref_name = 'LEVEL' then
      :new.pref_value := upper(:new.pref_value);
    end if;

    -- TODO mdsouza: 3.1.1
    -- TODO mdsouza: if removing then decrease indent
    -- $if $$currently_installing is null or not $$currently_installing $then
      -- Since logger.pks may not be installed when this trigger is compiled, need to move some code here
      if 1=1
        and :new.pref_type = logger.g_pref_type_logger
        and :new.pref_name = 'LEVEL'
        and upper(:new.pref_value) not in (logger.g_off_name, logger.g_permanent_name, logger.g_error_name, logger.g_warning_name, logger.g_information_name, logger.g_debug_name, logger.g_timing_name, logger.g_sys_context_name, logger.g_apex_name) then
        raise_application_error(-20000, '"LEVEL" must be one of the following values: ' ||
          logger.g_off_name || ', ' || logger.g_permanent_name || ', ' || logger.g_error_name || ', ' ||
          logger.g_warning_name || ', ' || logger.g_information_name || ', ' || logger.g_debug_name || ', ' ||
          logger.g_timing_name || ', ' || logger.g_sys_context_name || ', ' || logger.g_apex_name);
      end if;

      -- Allow for null to be used for Plugins, then default to NONE
      if 1=1
        and :new.pref_type = logger.g_pref_type_logger
        and :new.pref_name like 'PLUGIN_FN%'
        and :new.pref_value is null then
        :new.pref_value := 'NONE';
      end if;

      -- #103
      -- Only predefined preferences and Custom Preferences are allowed
      -- Custom Preferences must be prefixed with CUST_
      if 1=1
        and :new.pref_type = logger.g_pref_type_logger
        and :new.pref_name not in (
          'GLOBAL_CONTEXT_NAME'
          ,'INCLUDE_CALL_STACK'
          ,'INSTALL_SCHEMA'
          ,'LEVEL'
          ,'LOGGER_DEBUG'
          ,'LOGGER_VERSION'
          ,'PLUGIN_FN_ERROR'
          ,'PREF_BY_CLIENT_ID_EXPIRE_HOURS'
          ,'PROTECT_ADMIN_PROCS'
          ,'PURGE_AFTER_DAYS'
          ,'PURGE_MIN_LEVEL'
        )
      then
        raise_application_error (-20000, 'Setting system level preferences are restricted to a set list.');
      end if;

      -- this is because the logger package is not installed yet.  We enable it in logger_configure
      logger.null_global_contexts;
    -- TODO mdsouza: 3.1.1
    -- $end
  $end -- $$logger_no_op_install
end;
/

alter trigger biu_logger_prefs disable;

declare
begin
  $if $$logger_no_op_install $then
    null;
  $else
    -- Configure Data
    merge into logger_prefs p
    using (
      select 'PURGE_AFTER_DAYS' pref_name, '7' pref_value from dual union
      select 'PURGE_MIN_LEVEL' pref_name, 'DEBUG' pref_value from dual union
      select 'LOGGER_VERSION' pref_name, '3.1.1' pref_value from dual union -- 3.1.1 will be replaced when running the build script
      select 'LEVEL' pref_name, 'DEBUG' pref_value from dual union
      select 'PROTECT_ADMIN_PROCS' pref_name, 'TRUE' pref_value from dual union
      select 'INCLUDE_CALL_STACK' pref_name, 'TRUE' pref_value from dual union
      select 'PREF_BY_CLIENT_ID_EXPIRE_HOURS' pref_name, '12' pref_value from dual union
      select 'INSTALL_SCHEMA' pref_name, sys_context('USERENV','CURRENT_SCHEMA') pref_value from dual union
      -- #46
      select 'PLUGIN_FN_ERROR' pref_name, 'NONE' pref_value from dual union
      -- #64
      select 'LOGGER_DEBUG' pref_name, 'FALSE' pref_value from dual
      ) d
      on (p.pref_name = d.pref_name)
    when matched then
      update set p.pref_value =
        case
          -- Only LOGGER_VERSION should be updated during an update
          when p.pref_name = 'LOGGER_VERSION' then d.pref_value
          else p.pref_value
        end
    when not matched then
      insert (p.pref_name,p.pref_value)
      values (d.pref_name,d.pref_value);
  $end
end;
/




-- #127: Add pref_type
declare
  type typ_tab_col is record (
    column_name varchar2(30),
    data_type varchar2(100));
  type typ_arr_tab_col is table of typ_tab_col index by pls_integer;

  l_count pls_integer;
  l_new_col typ_tab_col;
  l_new_cols typ_arr_tab_col;
begin

  l_new_col.column_name := 'PREF_TYPE';
  l_new_col.data_type := 'VARCHAR2(30)';
  l_new_cols(l_new_cols.count+1) := l_new_col;

  for i in 1 .. l_new_cols.count loop
    select count(1)
    into l_count
    from user_tab_columns
    where 1=1
      and upper(table_name) = upper('logger_prefs')
      and column_name = l_new_cols(i).column_name;

    if l_count = 0 then
      execute immediate 'alter table logger_prefs add (' || l_new_cols(i).column_name || ' ' || l_new_cols(i).data_type || ')';

      -- Custom post-add columns

      -- #127
      if lower(l_new_cols(i).column_name) = 'pref_type' then
        -- If "LOGGER" is changed then modify logger.pks g_logger_prefs_pref_type value
        execute immediate q'!update logger_prefs set pref_type = 'LOGGER'!';
        execute immediate q'!alter table logger_prefs modify pref_type not null!';
      end if;

    end if; -- l_count = 0
  end loop;

end;
/


-- #127 If old PK, then drop it
declare
  l_count pls_integer;
begin
  select count(*)
  into l_count
  from user_cons_columns
  where 1=1
    and constraint_name = 'LOGGER_PREFS_PK'
    and column_name != 'PREF_NAME';

  if l_count = 0 then
    -- PK only has one column, drop it and it will be rebuilt below
    execute immediate 'alter table logger_prefs drop constraint logger_prefs_pk';
  end if;

end;
/


-- Ensure that pref_name is upper
declare
  type typ_constraint is record(
    name user_constraints.constraint_name%type,
    condition varchar(500)
  );

  type typ_tab_constraint is table of typ_constraint index by pls_integer;

  l_constraint typ_constraint;
  l_constraints typ_tab_constraint;
  l_count pls_integer;
  l_sql varchar2(500);
begin
  l_constraint.name := 'LOGGER_PREFS_PK';
  l_constraint.condition := 'primary key (pref_type, pref_name)';
  l_constraints(l_constraints.count+1) := l_constraint;

  l_constraint.name := 'LOGGER_PREFS_CK1';
  l_constraint.condition := 'check (pref_name = upper(pref_name))';
  l_constraints(l_constraints.count+1) := l_constraint;

  l_constraint.name := 'LOGGER_PREFS_CK2';
  l_constraint.condition := 'check (pref_type = upper(pref_type))';
  l_constraints(l_constraints.count+1) := l_constraint;


  -- All pref names/types should be upper
  update logger_prefs
  set
    pref_name = upper(pref_name),
    pref_type = upper(pref_type)
  where 1=1
    or pref_name != upper(pref_name)
    or pref_type != upper(pref_type);

  for i in l_constraints.first .. l_constraints.last loop
    select count(1)
    into l_count
    from user_constraints
    where 1=1
      and table_name = 'LOGGER_PREFS'
      and constraint_name = l_constraints(i).name;

    if l_count = 0 then
      l_sql := 'alter table logger_prefs add constraint %CONSTRAINT_NAME% %CONSTRAINT_CONDITION%';
      l_sql := replace(l_sql, '%CONSTRAINT_NAME%', l_constraints(i).name);
      l_sql := replace(l_sql, '%CONSTRAINT_CONDITION%', l_constraints(i).condition);

      execute immediate l_sql;
    end if;
  end loop; -- l_constraints

end;
/

alter trigger biu_logger_prefs enable;

PROMPT tables/logger_logs_apex_items.sql 
-- Initial table script built from 1.4.0
declare
  l_count pls_integer;
  l_nullable user_tab_columns.nullable%type;

  type typ_required_columns is table of varchar2(30) index by pls_integer;
  l_required_columns typ_required_columns;

begin

  -- Create Table
  select count(1)
  into l_count
  from user_tables
  where table_name = 'LOGGER_LOGS_APEX_ITEMS';

  if l_count = 0 then
    execute immediate '
create table logger_logs_apex_items(
    id				number not null,
    log_id          number not null,
    app_session     number not null,
    item_name       varchar2(1000) not null,
    item_value      clob,
    constraint logger_logs_apx_itms_pk primary key (id) enable,
    constraint logger_logs_apx_itms_fk foreign key (log_id) references logger_logs(id) ON DELETE CASCADE
)
    ';
  end if;


  $if $$logger_no_op_install $then
    null;
  $else
    -- SEQUENCE
    select count(1)
    into l_count
    from user_sequences
    where sequence_name = 'LOGGER_APX_ITEMS_SEQ';

    if l_count = 0 then
      execute immediate '
  create sequence logger_apx_items_seq
    minvalue 1
    maxvalue 999999999999999999999999999
    start with 1
    increment by 1
    cache 20
      ';
    end if;

    -- INDEXES
    select count(1)
    into l_count
    from user_indexes
    where index_name = 'LOGGER_APEX_ITEMS_IDX1';

    if l_count = 0 then
      execute immediate 'create index logger_apex_items_idx1 on logger_logs_apex_items(log_id)';
    end if;
  $end -- $$logger_no_op_install
end;
/


create or replace trigger biu_logger_apex_items
  before insert or update on logger_logs_apex_items
for each row
begin
  $if $$logger_no_op_install $then
    null;
  $else
    :new.id := logger_apx_items_seq.nextval;
  $end
end;
/

PROMPT tables/logger_prefs_by_client_id.sql 
declare
  l_count pls_integer;
  l_nullable user_tab_columns.nullable%type;

  type typ_required_columns is table of varchar2(30) index by pls_integer;
  l_required_columns typ_required_columns;

  l_sql varchar2(2000);

begin
  -- Create Table
  select count(1)
  into l_count
  from user_tables
  where table_name = 'LOGGER_PREFS_BY_CLIENT_ID';

  if l_count = 0 then
    execute immediate q'!
create table logger_prefs_by_client_id(
  client_id varchar2(64) not null,
  logger_level varchar2(20) not null,
  include_call_stack varchar2(5) not null,
  created_date date default sysdate not null,
  expiry_date date not null,
  constraint logger_prefs_by_client_id_pk primary key (client_id) enable,
  constraint logger_prefs_by_client_id_ck1 check (logger_level in ('OFF','PERMANENT','ERROR','WARNING','INFORMATION','DEBUG','TIMING')),
  constraint logger_prefs_by_client_id_ck2 check (expiry_date >= created_date),
  constraint logger_prefs_by_client_id_ck3 check (include_call_stack in ('TRUE', 'FALSE'))
)
    !';
  end if;

  -- COMMENTS
  execute immediate q'!comment on table logger_prefs_by_client_id is 'Client specific logger levels. Only active client_ids/logger_levels will be maintained in this table'!';
  execute immediate q'!comment on column logger_prefs_by_client_id.client_id is 'Client identifier'!';
  execute immediate q'!comment on column logger_prefs_by_client_id.logger_level is 'Logger level. Must be OFF, PERMANENT, ERROR, WARNING, INFORMATION, DEBUG, TIMING'!';
  execute immediate q'!comment on column logger_prefs_by_client_id.include_call_stack is 'Include call stack in logging'!';
  execute immediate q'!comment on column logger_prefs_by_client_id.created_date is 'Date that entry was created on'!';
  execute immediate q'!comment on column logger_prefs_by_client_id.expiry_date is 'After the given expiry date the logger_level will be disabled for the specific client_id. Unless sepcifically removed from this table a job will clean up old entries'!';


  -- 92: Missing APEX and SYS_CONTEXT support
  l_sql := 'alter table logger_prefs_by_client_id drop constraint logger_prefs_by_client_id_ck1';
  execute immediate l_sql;

  -- Rebuild constraint
  l_sql := q'!alter table logger_prefs_by_client_id
    add constraint logger_prefs_by_client_id_ck1
    check (logger_level in ('OFF','PERMANENT','ERROR','WARNING','INFORMATION','DEBUG','TIMING', 'APEX', 'SYS_CONTEXT'))!';
  execute immediate l_sql;

end;
/

PROMPT jobs/logger_purge_job.sql 
declare
  l_count pls_integer;
  l_job_name user_scheduler_jobs.job_name%type := 'LOGGER_PURGE_JOB';
begin
  
  select count(1)
  into l_count
  from user_scheduler_jobs
  where job_name = l_job_name;
  
  if l_count = 0 then
    dbms_scheduler.create_job(
       job_name => l_job_name,
       job_type => 'PLSQL_BLOCK',
       job_action => 'begin logger.purge; end; ',
       start_date => systimestamp,
       repeat_interval => 'FREQ=DAILY; BYHOUR=1',
       enabled => TRUE,
       comments => 'Purges LOGGER_LOGS using default values defined in logger_prefs.');
  end if;
end;
/
PROMPT jobs/logger_unset_prefs_by_client.sql 
declare
  l_count pls_integer;
  l_job_name user_scheduler_jobs.job_name%type := 'LOGGER_UNSET_PREFS_BY_CLIENT';
begin
  
  select count(1)
  into l_count
  from user_scheduler_jobs
  where job_name = l_job_name;
  
  if l_count = 0 then
    dbms_scheduler.create_job(
       job_name => l_job_name,
       job_type => 'PLSQL_BLOCK',
       job_action => 'begin logger.unset_client_level; end; ',
       start_date => systimestamp,
       repeat_interval => 'FREQ=HOURLY; BYHOUR=1',
       enabled => TRUE,
       comments => 'Clears logger prefs by client_id');
  end if;
end;
/
PROMPT views/logger_logs_5_min.sql 
create or replace force view logger_logs_5_min as
	select * 
      from logger_logs 
	 where time_stamp > systimestamp - (5/1440)
/
PROMPT views/logger_logs_60_min.sql 
create or replace force view logger_logs_60_min as
	select * 
      from logger_logs 
	 where time_stamp > systimestamp - (1/24)
/

PROMPT views/logger_logs_terse.sql
set termout off
-- setting termout off as this view will install with an error as it depends on logger.date_text_format
create or replace force view logger_logs_terse as
 select id, logger_level, 
        substr(logger.date_text_format(time_stamp),1,20) time_ago,
        substr(text,1,200) text
   from logger_logs
  where time_stamp > systimestamp - (5/1440)
  order by id asc
/

set termout on

PROMPT packages/logger.pks 
create or replace package logger
  authid definer
as
  -- This project using the following MIT License:
  --
  -- The MIT License (MIT)
  --
  -- Copyright (c) 2015 OraOpenSource
  --
  -- Permission is hereby granted, free of charge, to any person obtaining a copy
  -- of this software and associated documentation files (the "Software"), to deal
  -- in the Software without restriction, including without limitation the rights
  -- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  -- copies of the Software, and to permit persons to whom the Software is
  -- furnished to do so, subject to the following conditions:
  --
  -- The above copyright notice and this permission notice shall be included in all
  -- copies or substantial portions of the Software.
  --
  -- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  -- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  -- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  -- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  -- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  -- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  -- SOFTWARE.


  -- TYPES
  type rec_param is record(
    name varchar2(255),
    val varchar2(4000));

  type tab_param is table of rec_param index by binary_integer;

  type rec_logger_log is record(
    id logger_logs.id%type,
    logger_level logger_logs.logger_level%type
  );


  -- VARIABLES
	g_logger_version constant varchar2(10) := '3.1.1'; -- Don't change this. Build script will replace with right version number
	g_context_name constant varchar2(35) := substr(sys_context('USERENV','CURRENT_SCHEMA'),1,23)||'_LOGCTX';

  g_off constant number := 0;
  g_permanent constant number := 1;
	g_error constant number := 2;
	g_warning constant number := 4;
	g_information constant number := 8;
  g_debug constant number := 16;
	g_timing constant number := 32;
  g_sys_context constant number := 64;
  g_apex constant number := 128;

  -- #44
  g_off_name constant varchar2(30) := 'OFF';
  g_permanent_name constant varchar2(30) := 'PERMANENT';
  g_error_name constant varchar2(30) := 'ERROR';
  g_warning_name constant varchar2(30) := 'WARNING';
  g_information_name constant varchar2(30) := 'INFORMATION';
  g_debug_name constant varchar2(30) := 'DEBUG';
  g_timing_name constant varchar2(30) := 'TIMING';
  g_sys_context_name constant varchar2(30) := 'SYS_CONTEXT';
  g_apex_name constant varchar2(30) := 'APEX';

  gc_empty_tab_param tab_param;

  -- #54: Types for log_apex_items
  g_apex_item_type_all constant varchar2(30) := 'ALL'; -- Application items and page items
  g_apex_item_type_app constant varchar2(30) := 'APP'; -- All application items
  g_apex_item_type_page constant varchar2(30) := 'PAGE'; -- All page items
  -- To log items on a particular page, just enter the page number

  -- #127
  -- Note to developers: This is only for internal Logger code. Do not use this as part of your code.
  g_pref_type_logger constant logger_prefs.pref_type%type := 'LOGGER'; -- If this changes need to modify logger_prefs.sql as it has a dependancy.

  -- Expose private functions only for testing during development
  $if $$logger_debug $then
    function is_number(p_str in varchar2)
      return boolean;

    procedure assert(
      p_condition in boolean,
      p_message in varchar2);

    function get_param_clob(p_params in logger.tab_param)
      return clob;

    procedure save_global_context(
      p_attribute in varchar2,
      p_value in varchar2,
      p_client_id in varchar2 default null);

    function set_extra_with_params(
      p_extra in logger_logs.extra%type,
      p_params in tab_param)
      return logger_logs.extra%type;

    function get_sys_context(
      p_detail_level in varchar2 default 'USER', -- ALL, NLS, USER, INSTANCE
      p_vertical in boolean default false,
      p_show_null in boolean default false)
      return clob;

    function admin_security_check
      return boolean;

    function get_level_number
      return number;

    function include_call_stack
      return boolean;

    function date_text_format_base (
      p_date_start in date,
      p_date_stop  in date)
      return varchar2;

    procedure log_internal(
      p_text in varchar2,
      p_log_level in number,
      p_scope in varchar2,
      p_extra in clob default null,
      p_callstack in varchar2 default null,
      p_params in tab_param default logger.gc_empty_tab_param);
  $end

  -- PROCEDURES and FUNCTIONS

  procedure null_global_contexts;

  function convert_level_char_to_num(
    p_level in varchar2)
    return number;

  function convert_level_num_to_char(
    p_level in number)
    return varchar2;

  function date_text_format (p_date in date)
    return varchar2;

	function get_character_codes(
		p_string 				in varchar2,
		p_show_common_codes 	in boolean default true)
    return varchar2;

  procedure log_error(
    p_text          in varchar2 default null,
    p_scope         in varchar2 default null,
    p_extra         in clob default null,
    p_params        in tab_param default logger.gc_empty_tab_param);

  procedure log_permanent(
    p_text    in varchar2,
    p_scope   in varchar2 default null,
    p_extra   in clob default null,
    p_params  in tab_param default logger.gc_empty_tab_param);

  procedure log_warning(
    p_text    in varchar2,
    p_scope   in varchar2 default null,
    p_extra   in clob default null,
    p_params  in tab_param default logger.gc_empty_tab_param);

  procedure log_warn(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param);

  procedure log_information(
    p_text    in varchar2,
    p_scope   in varchar2 default null,
    p_extra   in clob default null,
    p_params  in tab_param default logger.gc_empty_tab_param);

  procedure log_info(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param);

  procedure log(
    p_text    in varchar2,
    p_scope   in varchar2 default null,
    p_extra   in clob default null,
    p_params  in tab_param default logger.gc_empty_tab_param);

  function get_cgi_env(
    p_show_null		in boolean default false)
  	return clob;

  procedure log_userenv(
    p_detail_level in varchar2 default 'USER',-- ALL, NLS, USER, INSTANCE,
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null);

  procedure log_cgi_env(
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null);

  procedure log_character_codes(
    p_text in varchar2,
    p_scope in logger_logs.scope%type default null,
    p_show_common_codes in boolean default true,
    p_level in logger_logs.logger_level%type default null);

    procedure log_apex_items(
      p_text in varchar2 default 'Log APEX Items',
      p_scope in logger_logs.scope%type default null,
      p_item_type in varchar2 default logger.g_apex_item_type_all,
      p_log_null_items in boolean default true,
      p_level in logger_logs.logger_level%type default null);

	procedure time_start(
		p_unit in varchar2,
    p_log_in_table in boolean default true);

	procedure time_stop(
		p_unit in varchar2,
    p_scope in varchar2 default null);

  function time_stop(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table in boolean default true)
    return varchar2;

  function time_stop_seconds(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table in boolean default true)
    return number;

  procedure time_reset;

  function get_pref(
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_type in logger_prefs.pref_type%type default logger.g_pref_type_logger)
    return varchar2
    $if not dbms_db_version.ver_le_10_2  $then
      result_cache
    $end;

  -- #103
  procedure set_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_value in logger_prefs.pref_value%type);

  -- #103
  procedure del_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type);

	procedure purge(
		p_purge_after_days in varchar2 default null,
		p_purge_min_level	in varchar2	default null);

  procedure purge(
    p_purge_after_days in number default null,
    p_purge_min_level in number);

	procedure purge_all;

	procedure status(
		p_output_format	in varchar2 default null); -- SQL-DEVELOPER | HTML | DBMS_OUPUT

  procedure sqlplus_format;

  procedure set_level(
    p_level in varchar2 default logger.g_debug_name,
    p_client_id in varchar2 default null,
    p_include_call_stack in varchar2 default null,
    p_client_id_expire_hours in number default null
  );

  procedure unset_client_level(p_client_id in varchar2);

  procedure unset_client_level;

  procedure unset_client_level_all;


  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in varchar2);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in number);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in date);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with time zone);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with local time zone);

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in boolean);

  function ok_to_log(p_level in number)
    return boolean;

  function ok_to_log(p_level in varchar2)
    return boolean;

  function tochar(
    p_val in number)
    return varchar2;

  function tochar(
    p_val in date)
    return varchar2;

  function tochar(
    p_val in timestamp)
    return varchar2;

  function tochar(
    p_val in timestamp with time zone)
    return varchar2;

  function tochar(
    p_val in timestamp with local time zone)
    return varchar2;

  function tochar(
    p_val in boolean)
    return varchar2;

  procedure ins_logger_logs(
    p_logger_level in logger_logs.logger_level%type,
    p_text in varchar2 default null, -- Not using type since want to be able to pass in 32767 characters
    p_scope in logger_logs.scope%type default null,
    p_call_stack in logger_logs.call_stack%type default null,
    p_unit_name in logger_logs.unit_name%type default null,
    p_line_no in logger_logs.line_no%type default null,
    p_extra in logger_logs.extra%type default null,
    po_id out nocopy logger_logs.id%type
  );


  function sprintf(
    p_str in varchar2,
    p_s1 in varchar2 default null,
    p_s2 in varchar2 default null,
    p_s3 in varchar2 default null,
    p_s4 in varchar2 default null,
    p_s5 in varchar2 default null,
    p_s6 in varchar2 default null,
    p_s7 in varchar2 default null,
    p_s8 in varchar2 default null,
    p_s9 in varchar2 default null,
    p_s10 in varchar2 default null)
    return varchar2;

  function get_plugin_rec(
    p_logger_level in logger_logs.logger_level%type)
    return logger.rec_logger_log;
end logger;
/

PROMPT packages/logger.pkb 
create or replace package body logger
as
  -- Note: The license is defined in the package specification of the logger package
  --
  -- Conditional Compilation variables:
  -- $$NO_OP
  --  When true, completely disables all logger DML.Also used to generate the logger_no_op.sql file
  --
  -- $$RAC_LT_11_2:
  --  Set in logger_configure.
  --  Handles the fact that RAC doesn't support global app contexts until 11.2
  --
  -- $$FLASHBACK_ENABLED
  --  Set in logger_configure.
  --  Determine whether or not we can grab the scn from dbms_flashback.
  --  Primarily used in the trigger on logger_logs.
  --
  -- $$APEX
  --  Set in logger_configure.
  --  True if we can query a local synonym to wwv_flow_data to snapshot the APEX session state.
  --
  -- $$LOGGER_DEBUG
  --  Only to be used during development of logger
  --  Primarily used for dbms_output.put_line calls
  --  Part of #64
  --
  -- $$LOGGER_PLUGIN_<TYPE> : For each type of plugin
  --  Introduced with #46
  --  $$LOGGER_PLUGIN_ERROR
  --


  -- TYPES
  type ts_array is table of timestamp index by varchar2(100);


  -- VARIABLES
  g_log_id number;
  g_proc_start_times ts_array;
  g_running_timers pls_integer := 0;

  -- #46
  g_plug_logger_log_error rec_logger_log;

  g_in_plugin_error boolean := false;






  -- CONSTANTS
  gc_line_feed constant varchar2(1) := chr(10);
  gc_cflf constant varchar2(2) := chr(13)||chr(10);
  gc_date_format constant varchar2(255) := 'DD-MON-YYYY HH24:MI:SS';
  gc_timestamp_format constant varchar2(255) := gc_date_format || ':FF';
  gc_timestamp_tz_format constant varchar2(255) := gc_timestamp_format || ' TZR';

  gc_ctx_attr_level constant varchar2(5) := 'level';
  gc_ctx_attr_include_call_stack constant varchar2(18) := 'include_call_stack';

  -- #46 Plugin context names
  gc_ctx_plugin_fn_log constant varchar2(30) := 'plugin_fn_log';
  gc_ctx_plugin_fn_info constant varchar2(30) := 'plugin_fn_information';
  gc_ctx_plugin_fn_warn constant varchar2(30) := 'plugin_fn_warning';
  gc_ctx_plugin_fn_error constant varchar2(30) := 'plugin_fn_error';
  gc_ctx_plugin_fn_perm constant varchar2(30) := 'plugin_fn_permanent';

  -- #113 Preference names
  gc_pref_level constant logger_prefs.pref_name%type := 'LEVEL';
  gc_pref_include_call_stack constant logger_prefs.pref_name%type := 'INCLUDE_CALL_STACK';
  gc_pref_protect_admin_procs constant logger_prefs.pref_name%type := 'PROTECT_ADMIN_PROCS';
  gc_pref_install_schema constant logger_prefs.pref_name%type := 'INSTALL_SCHEMA';
  gc_pref_purge_after_days constant logger_prefs.pref_name%type := 'PURGE_AFTER_DAYS';
  gc_pref_purge_min_level constant logger_prefs.pref_name%type := 'PURGE_MIN_LEVEL';
  gc_pref_logger_version constant logger_prefs.pref_name%type := 'LOGGER_VERSION';
  gc_pref_client_id_expire_hours constant logger_prefs.pref_name%type := 'PREF_BY_CLIENT_ID_EXPIRE_HOURS';
  gc_pref_logger_debug constant logger_prefs.pref_name%type := 'LOGGER_DEBUG';
  gc_pref_plugin_fn_error constant logger_prefs.pref_name%type := 'PLUGIN_FN_ERROR';




  -- *** PRIVATE ***

  /**
   *
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created
   * @param p_str
   * @return True if p_str is a number
   */
  function is_number(p_str in varchar2)
    return boolean
  as
    l_num number;
  begin
    l_num := to_number(p_str);
    return true;
  exception
    when others then
      return false;
  end is_number;


  /**
   * Validates assertion. Will raise an application error if assertion is false
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 29-Mar-2013
   * @param p_condition Boolean condition to validate
   * @param p_message Message to include in application error if p_condition fails
   */
  procedure assert(
    p_condition in boolean,
    p_message in varchar2)
  as
  begin
    $if $$no_op $then
      null;
    $else
      if not p_condition or p_condition is null then
        raise_application_error(-20000, p_message);
      end if;
    $end
  end assert;


  /**
   * Returns the display/print friendly parameter information
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 20-Jan-2013
   * @param p_parms Array of parameters (can be null)
   * @return Clob of param information
   */
  function get_param_clob(p_params in logger.tab_param)
    return clob
  as
    l_return clob;
    l_no_vars constant varchar2(255) := 'No params defined';
    l_index pls_integer;
  begin

    $if $$no_op $then
      return null;
    $else
      -- Generate line feed delimited list
      if p_params.count > 0 then
        -- Using while true ... option allows for unordered param list
        l_index := p_params.first;
        while true loop
          l_return := l_return || p_params(l_index).name || ': ' || p_params(l_index).val;

          l_index := p_params.next(l_index);

          if l_index is null then
            exit;
          else
            l_return := l_return || gc_line_feed;
          end if;
        end loop;

      else
        -- No Parameters
        l_return := l_no_vars;
      end if;

      return l_return;
    $end
  end get_param_clob;



  /**
   * Sets the global context
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_attribute Attribute for context to set
   * @param p_value Value
   * @param p_client_id Optional client_id. If specified will only set the attribute/value for specific client_id (not global)
   */
  procedure save_global_context(
    p_attribute in varchar2,
    p_value in varchar2,
    p_client_id in varchar2 default null)
  is
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      dbms_session.set_context(
        namespace => g_context_name,
        attribute => p_attribute,
        value => p_value,
        client_id => p_client_id);
    $end

    commit; -- MD: moved commit to outside of the NO_OP check since commit or rollback must occur in this procedure
  end save_global_context;



  /**
   * Will return the extra column appended with the display friendly parameters
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 1-May-2013
   * @param p_extra Current "Extra" field
   * @param p_params Parameters. If null, then no changes to the Extra column
   */
  function set_extra_with_params(
    p_extra in logger_logs.extra%type,
    p_params in tab_param
  )
    return logger_logs.extra%type
  as
    l_extra logger_logs.extra%type;
  begin
    $if $$no_op $then
      return null;
    $else
      if p_params.count = 0 then
        return p_extra;
      else
        l_extra := p_extra || gc_line_feed || gc_line_feed || '*** Parameters ***' || gc_line_feed || gc_line_feed || get_param_clob(p_params => p_params);
      end if;

      return l_extra;
    $end

  end set_extra_with_params;


  /**
   * Returns common system level context values
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_detail_level USER, ALL, NLS, USER, or INSTANCe
   * @param p_vertical True of values should have a line break after each value. False for comman seperated list.
   * @param p_show_null Show null values
   * @return
   */
  function get_sys_context(
    p_detail_level in varchar2 default 'USER', -- ALL, NLS, USER, INSTANCE
    p_vertical in boolean default false,
    p_show_null in boolean default false)
    return clob
  is
    l_ctx clob;
    l_detail_level varchar2(20) := upper(p_detail_level);

    procedure append_ctx(p_name in varchar2)
    is
      r_pad number := 30;
      l_value varchar2(100);

      invalid_userenv_parm exception;
      pragma exception_init(invalid_userenv_parm, -2003);

    begin
      l_value := sys_context('USERENV',p_name);

      if p_show_null or l_value is not null then
        if p_vertical then
          l_ctx := l_ctx || rpad(p_name,r_pad,' ')||': '|| l_value || gc_cflf;
        else
          l_ctx := l_ctx || p_name||': '|| l_value ||', ';
        end if;
      end if;
    exception
      when invalid_userenv_parm then
        null;
    end append_ctx;


  begin
    $if $$no_op $then
      return null;
    $else
      if l_detail_level in ('ALL','NLS','INSTANCE') then
        append_ctx('NLS_CALENDAR');
        append_ctx('NLS_CURRENCY');
        append_ctx('NLS_DATE_FORMAT');
        append_ctx('NLS_DATE_LANGUAGE');
        append_ctx('NLS_SORT');
        append_ctx('NLS_TERRITORY');
        append_ctx('LANG');
        append_ctx('LANGUAGE');
      end if;
      if l_detail_level in ('ALL','USER') then
        append_ctx('CURRENT_SCHEMA');
        append_ctx('SESSION_USER');
        append_ctx('OS_USER');
        append_ctx('CLIENT_IDENTIFIER');
        append_ctx('CLIENT_INFO');
        append_ctx('IP_ADDRESS');
        append_ctx('HOST');
        append_ctx('TERMINAL');
      end if;

      if l_detail_level in ('ALL','USER') then
        append_ctx('AUTHENTICATED_IDENTITY');
        append_ctx('AUTHENTICATION_DATA');
        append_ctx('AUTHENTICATION_METHOD');
        append_ctx('ENTERPRISE_IDENTITY');
        append_ctx('POLICY_INVOKER');
        append_ctx('PROXY_ENTERPRISE_IDENTITY');
        append_ctx('PROXY_GLOBAL_UID');
        append_ctx('PROXY_USER');
        append_ctx('PROXY_USERID');
        append_ctx('IDENTIFICATION_TYPE');
        append_ctx('ISDBA');
      end if;

      if l_detail_level in ('ALL','INSTANCE') then
        append_ctx('DB_DOMAIN');
        append_ctx('DB_NAME');
        append_ctx('DB_UNIQUE_NAME');
        append_ctx('INSTANCE');
        append_ctx('INSTANCE_NAME');
        append_ctx('SERVER_HOST');
        append_ctx('SERVICE_NAME');
      end if;

      if l_detail_level in ('ALL') then
        append_ctx('ACTION');
        append_ctx('AUDITED_CURSORID');
        append_ctx('BG_JOB_ID');
        append_ctx('CURRENT_BIND');
        append_ctx('CURRENT_SCHEMAID');
        append_ctx('CURRENT_SQL');
        append_ctx('CURRENT_SQLn');
        append_ctx('CURRENT_SQL_LENGTH');
        append_ctx('ENTRYID');
        append_ctx('FG_JOB_ID');
        append_ctx('GLOBAL_CONTEXT_MEMORY');
        append_ctx('GLOBAL_UID');
        append_ctx('MODULE');
        append_ctx('NETWORK_PROTOCOL');
        append_ctx('SESSION_USERID');
        append_ctx('SESSIONID');
        append_ctx('SID');
        append_ctx('STATEMENTID');
      end if;

      return rtrim(l_ctx,', ');
    $end
  end get_sys_context;


  /**
   * Checks if admin functions can be run
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @return True if user can run admin procs.
   */
 function admin_security_check
    return boolean
  is
    l_protect_admin_procs logger_prefs.pref_value%type;
    l_return boolean default false;
  begin
    $if $$no_op $then
      l_return := true;
    $else
      l_protect_admin_procs := get_pref(logger.gc_pref_protect_admin_procs);
      if l_protect_admin_procs = 'TRUE' then
        if get_pref(logger.gc_pref_install_schema) = sys_context('USERENV','SESSION_USER') then
          l_return := true;
        else
          l_return := false;
          raise_application_error (-20000, 'You are not authorized to call this procedure. Change Logger pref: PROTECT_ADMIN_PROCS to false to avoid this.');
        end if;
      else
        l_return := true;
      end if;
    $end

    return l_return;

  end admin_security_check;


  /**
   *
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  - #111 Use get_pref to remove duplicate code
   *
   * @author Tyler Muth
   * @created ???
   * @param
   * @return If client level specified will return it, otherwise global level.
   */
  function get_level_number
    return number
    $if $$rac_lt_11_2 $then
      $if not dbms_db_version.ver_le_10_2 $then
        result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
      $end
    $end
  is
    l_level number;
    l_level_char varchar2(50);

    $if $$logger_debug $then
      l_scope varchar2(30) := 'get_level_number';
    $end

  begin
    $if $$no_op $then
      return g_off;
    $else
      $if $$logger_debug $then
        dbms_output.put_line(l_scope || ': selecting logger_level');
      $end

      l_level := convert_level_char_to_num(logger.get_pref(logger.gc_pref_level));

      return l_level;
    $end
  end get_level_number;


  /**
   * Determines if callstack should be while logging
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @return
   */
  function include_call_stack
    return boolean
    $if 1=1
      and $$rac_lt_11_2
      and not dbms_db_version.ver_le_10_2
      and ($$no_op is null or not $$no_op) $then
        result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
    $end
  is
    l_call_stack_pref logger_prefs.pref_value%type;
  begin
    $if $$no_op $then
      return false;
    $else
      $if $$rac_lt_11_2 $then
        l_call_stack_pref := get_pref(logger.gc_pref_include_call_stack);
      $else
        l_call_stack_pref := sys_context(g_context_name,gc_ctx_attr_include_call_stack);

        if l_call_stack_pref is null then
          l_call_stack_pref := get_pref(logger.gc_pref_include_call_stack);
          save_global_context(
            p_attribute => gc_ctx_attr_include_call_stack,
            p_value => l_call_stack_pref,
            p_client_id => sys_context('userenv','client_identifier'));
        end if;
      $end

      if l_call_stack_pref = 'TRUE' then
        return true;
      else
        return false;
      end if;
    $end
  end include_call_stack;


  /**
   * Returns date diff in "... sectons/minutes/days/etc ago" format
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_date_start
   * @param p_date_stop
   * @return Text version of date diff
   */
  function date_text_format_base (
    p_date_start in date,
    p_date_stop  in date)
  return varchar2
  as
    x varchar2(20);
  begin
    $if $$no_op $then
      return null;
    $else
      x :=
        case
          when p_date_stop-p_date_start < 1/1440
            then round(24*60*60*(p_date_stop-p_date_start)) || ' seconds'
          when p_date_stop-p_date_start < 1/24
            then round(24*60*(p_date_stop-p_date_start)) || ' minutes'
          when p_date_stop-p_date_start < 1
            then round(24*(p_date_stop-p_date_start)) || ' hours'
          when p_date_stop-p_date_start < 14
            then trunc(p_date_stop-p_date_start) || ' days'
          when p_date_stop-p_date_start < 60
            then trunc((p_date_stop-p_date_start)/7) || ' weeks'
          when p_date_stop-p_date_start < 365
            then round(months_between(p_date_stop,p_date_start)) || ' months'
          else round(months_between(p_date_stop,p_date_start)/12,1) || ' years'
        end;
      x:= regexp_replace(x,'(^1 [[:alnum:]]{4,10})s','\1');
      x:= x || ' ago';
      return substr(x,1,20);
    $end
  end date_text_format_base;


  /**
   * Parses the callstack to get unit and line number
   *
   * Notes:
   *  - Private
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_callstack
   * @param o_unit
   * @param o_lineno
   */
  procedure get_debug_info(
    p_callstack in clob,
    o_unit out varchar2,
    o_lineno out varchar2 )
  as
    --
    l_callstack varchar2(10000) := p_callstack;
  begin
    $if $$no_op $then
      null;
    $else
      l_callstack := substr( l_callstack, instr( l_callstack, chr(10), 1, 5 )+1 );
      l_callstack := substr( l_callstack, 1, instr( l_callstack, chr(10), 1, 1 )-1 );
      l_callstack := trim( substr( l_callstack, instr( l_callstack, ' ' ) ) );
      o_lineno := substr( l_callstack, 1, instr( l_callstack, ' ' )-1 );
      o_unit := trim(substr( l_callstack, instr( l_callstack, ' ', -1, 1 ) ));
    $end
  end get_debug_info;


  /**
   * Main procedure that will store log data into logger_logs table
   *
   *
   * Modifications
   *  - 2.1.0: If text is > 4000 characters, it will be moved to the EXTRA column
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_log_level
   * @param p_scope
   * @param p_extra
   * @param p_callstack
   * @param p_params
   *
   */
  procedure log_internal(
    p_text in varchar2,
    p_log_level in number,
    p_scope in varchar2,
    p_extra in clob default null,
    p_callstack in varchar2 default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
    l_proc_name varchar2(100);
    l_lineno varchar2(100);
    l_text varchar2(32767);
    l_callstack varchar2(3000);
    l_extra logger_logs.extra%type;
  begin
    $if $$no_op $then
      null;
    $else
      l_text := p_text;

      -- Generate callstack text
      if p_callstack is not null and logger.include_call_stack then
        logger.get_debug_info(
          p_callstack => p_callstack,
          o_unit => l_proc_name,
          o_lineno => l_lineno);

        l_callstack  := regexp_replace(p_callstack,'^.*$','',1,4,'m');
        l_callstack  := regexp_replace(l_callstack,'^.*$','',1,1,'m');
        l_callstack  := ltrim(replace(l_callstack,chr(10)||chr(10),chr(10)),chr(10));

      end if;

      l_extra := set_extra_with_params(p_extra => p_extra, p_params => p_params);

      ins_logger_logs(
        p_unit_name => upper(l_proc_name) ,
        p_scope => p_scope ,
        p_logger_level =>p_log_level,
        p_extra => l_extra,
        p_text =>l_text,
        p_call_stack  =>l_callstack,
        p_line_no => l_lineno,
        po_id => g_log_id);
    $end
  end log_internal;


  /**
   * Run plugin
   *
   * Notes:
   *  - Currently only supports error type plugin but has been built to support other types
   *  - -- FUTURE mdsouza: When supporting other plugin types put conditional compilation where applicable
   *  - -- FUTURE mdsouza: Include this in tests (#86)
   *
   * Related Tickets:
   *  - #46
   *
   * @author Martin D'Souza
   * @created 11-Mar-2015
   * @param p_logger_log Record that plugin should be run for
   */
  procedure run_plugin(p_logger_log in logger.rec_logger_log)
  as
    l_plugin_fn logger_prefs.pref_value%type;
    l_plugin_ctx varchar2(30);

    l_sql varchar2(255);

    -- For exception block
    l_params logger.tab_param;
    l_scope logger_logs.scope%type;

    -- Mark "in_plugin" as true/false
    -- Put in separate procedure since more logic may be applied
    -- And called from exception block as well
    procedure start_stop_plugin(
      p_in_plugin boolean -- True/False depending on action
    )
    as
    begin
      if p_logger_log.logger_level = logger.g_error then
        g_in_plugin_error := p_in_plugin;
      end if;
    end start_stop_plugin;

    function f_get_set_global_context(
      p_ctx in varchar2
    )
      return varchar2
    as
      l_return varchar2(255);
    begin
      $if $$logger_debug $then
        dbms_output.put_line('Calling f_get_set_global_conext');
      $end

      l_return := upper(get_pref(p_pref_name =>
        case
          when p_logger_log.logger_level = g_error then gc_ctx_plugin_fn_error
        end
      ));

      $if $$logger_debug $then
        dbms_output.put_line('l_return: ' || l_return);
      $end

      save_global_context(p_attribute => p_ctx, p_value => l_return);
      return l_return;
    end f_get_set_global_context;

  begin
    start_stop_plugin(p_in_plugin => true);

    $if $$logger_debug $then
      dbms_output.put_line('in run_plugin. g_in_plugin_error: ' || logger.tochar(g_in_plugin_error));
    $end

    if 1=2 then
      null;
    elsif p_logger_log.logger_level = logger.g_error then
      l_plugin_ctx := gc_ctx_plugin_fn_error;
    end if;

    if l_plugin_ctx is not null then
      l_plugin_fn := coalesce(
        sys_context(g_context_name, l_plugin_ctx),
        f_get_set_global_context(p_ctx => l_plugin_ctx));

      $if $$logger_debug $then
        dbms_output.put_line('l_plugin_fn: ' || l_plugin_fn);
      $end

      if 1=1
        and l_plugin_fn is not null
        and l_plugin_fn != 'NONE' then

        l_sql := 'begin ' || l_plugin_fn || '(logger.get_plugin_rec(' || p_logger_log.logger_level || ')); end;';

        $if $$logger_debug $then
          dbms_output.put_line('l_sql: ' || l_sql);
        $end

        execute immediate l_sql;

      else
        -- Should never reach this point since plugin_fn should have a value
        logger.log_error('Error l_plugin_fn does not have value');
      end if; -- l_plugin_fn
    else
      -- Should never reach this point since plugin_ctx should have a value
      logger.log_error('Error l_plugin_ctx does not have value');
    end if; -- l_plugin_ctx is not null

    start_stop_plugin(p_in_plugin => false);

  exception
    when others then
      logger.append_param(l_params, 'Logger.id', p_logger_log.id);
      logger.append_param(l_params, 'Logger.logger_level', p_logger_log.logger_level);
      logger.append_param(l_params, 'Plugin Function', l_plugin_fn);

      select scope
      into l_scope
      from logger_logs_5_min
      where 1=1
        and id = p_logger_log.id;

      logger.log_error('Exception in plugin procedure: ' || l_plugin_fn, l_scope, null, l_params);

      start_stop_plugin(p_in_plugin => false);

      raise;
  end run_plugin;




  -- **** PUBLIC ****


  /**
   * Sets all the contexts to null
   *
   * Notes:
   *  - Though this is public it is not a documented procedure. Only used with logger_configure.
   *
   * Related Tickets:
   *  - #46 Plugin support
   *  - #110 Clear all contexts (including ones with client identifier)
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure null_global_contexts
  is
    pragma autonomous_transaction;
  begin
    $if $$no_op or $$rac_lt_11_2 $then
      null;
    $else
      dbms_session.clear_all_context(
         namespace => g_context_name);
    $end

    commit;
  end null_global_contexts;


  /**
   * Converts string names to text value
   *
   * Changes
   *  - 2.1.0: Start to use global variables and correct numbers
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level String representation of level
   * @return level number. -1 if not found
   */
  function convert_level_char_to_num(
    p_level in varchar2)
    return number
  is
    l_level         number;
  begin
    $if $$no_op $then
      return null;
    $else
      case p_level
        when g_off_name then l_level := g_off;
        when g_permanent_name then l_level := g_permanent;
        when g_error_name then l_level := g_error;
        when g_warning_name then l_level := g_warning;
        when g_information_name then l_level := g_information;
        when g_debug_name then l_level := g_debug;
        when g_timing_name then l_level := g_timing;
        when g_sys_context_name then l_level := g_sys_context;
        when g_apex_name then l_level := g_apex;
        else l_level := -1;
      end case;
    $end

    return l_level;
  end convert_level_char_to_num;


  /**
   * Converts the logger level num to char format
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #48
   *
   * @author Martin D'Souza
   * @created 14-Jun-2014
   * @param p_level
   * @return Logger level string format
   */
  function convert_level_num_to_char(
    p_level in number)
    return varchar2
  is
    l_return varchar2(255);
  begin
    $if $$no_op $then
      null;
    $else
      l_return :=
        case p_level
          when g_off then g_off_name
          when g_permanent then g_permanent_name
          when g_error then g_error_name
          when g_warning then g_warning_name
          when g_information then g_information_name
          when g_debug then g_debug_name
          when g_timing then g_timing_name
          when g_sys_context then g_sys_context_name
          when g_apex then g_apex_name
          else null
        end;
    $end

    return l_return;
  end convert_level_num_to_char;





  /**
   * Determines if the statement can be stored in LOGGER_LOGS
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #44: Expose publically
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level Level (number)
   * @return True of statement can be logged to LOGGER_LOGS
   */
  function ok_to_log(p_level in number)
    return boolean
    $if 1=1
      and $$rac_lt_11_2
      and not dbms_db_version.ver_le_10_2
      and ($$no_op is null or not $$no_op) $then
        result_cache relies_on (logger_prefs, logger_prefs_by_client_id)
    $end
  is
    l_level number;
    l_level_char varchar2(50);

    $if $$logger_debug $then
      l_scope varchar2(30) := 'ok_to_log';
    $end

  begin
    $if $$no_op $then
      return false;
    $else

      $if $$logger_debug $then
        dbms_output.put_line(l_scope || ': in function');
      $end

      $if $$rac_lt_11_2 $then
        $if $$logger_debug $then
          dbms_output.put_line(l_scope || ': calling get_level_number');
        $end
        l_level := get_level_number;
      $else
        l_level := sys_context(g_context_name,gc_ctx_attr_level);

        if l_level is null then
          $if $$logger_debug $then
            dbms_output.put_line(l_scope || ': level was null, getting and setting in context');
          $end

          l_level := get_level_number;

          save_global_context(
            p_attribute => gc_ctx_attr_level,
            p_value => l_level,
            p_client_id => sys_context('userenv','client_identifier'));
        end if;
      $end

      if l_level >= p_level then
        return true;
      else
        return false;
      end if;
   $end
  end ok_to_log;


  /**
   * Determines if log statements will actually be stored.
   *
   * @author Martin D'Souza
   * @created 25-Jul-2013
   *
   * @param p_level Level (DEBUG etc..)
   * @return True of log statements for that level or below will be logged
   */
  function ok_to_log(p_level in varchar2)
    return boolean
  as
  begin
    $if $$no_op $then
      return false;
    $else
      return ok_to_log(p_level => convert_level_char_to_num(p_level => p_level));
    $end
  end ok_to_log;




  /**
   * ???
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_date
   * @return
   */
  function date_text_format (p_date in date)
    return varchar2
  as
  begin
    $if $$no_op $then
      return null;
    $else
      return date_text_format_base(
        p_date_start => p_date   ,
        p_date_stop  => sysdate);
    $end
  end date_text_format;


  function get_character_codes(
    p_string        in varchar2,
    p_show_common_codes   in boolean default true)
    return varchar2
  is
    l_string  varchar2(32767);
    l_dump    varchar2(32767);
    l_return  varchar2(32767);
  begin
    -- replace tabs with ^
    l_string := replace(p_string,chr(9),'^');
    -- replace all other control characters such as carriage return / line feeds with ~
    l_string := regexp_replace(l_string,'[[:cntrl:]]','~',1,0,'m');

    select dump(p_string) into l_dump from dual;

    l_dump  := regexp_replace(l_dump,'(^.+?:)(.*)','\2',1,0); -- get everything after the :
    l_dump  := ','||l_dump||','; -- leading and trailing commas
    l_dump  := replace(l_dump,',',',,'); -- double the commas. this is for the regex.
    l_dump  := regexp_replace(l_dump,'(,)([[:digit:]]{1})(,)','\1  \2\3',1,0); -- lpad all single digit numbers out to 3
    l_dump  := regexp_replace(l_dump,'(,)([[:digit:]]{2})(,)','\1 \2\3',1,0);  -- lpad all double digit numbers out to 3
    l_dump  := ltrim(replace(l_dump,',,',','),','); -- remove the double commas
    l_dump  := lpad(' ',(5-instr(l_dump,',')),' ')||l_dump;

    -- replace every individual character with 2 spaces, itself and a comma so it lines up with the dump output
    l_string := ' '||regexp_replace(l_string,'(.){1}','  \1,',1,0);

    l_return := rtrim(l_dump,',') || chr(10) || rtrim(l_string,',');

    if p_show_common_codes then
      l_return := 'Common Codes: 13=Line Feed, 10=Carriage Return, 32=Space, 9=Tab'||chr(10) ||l_return;
    end if;

    return l_return;

  end get_character_codes;

  /**
   * Store APEX items in logger_logs_apex_items
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #115: Only log not-null values
   *  - #114: Bulk insert (no more row by row)
   *  - #54: Support for p_item_type
   *
   * @author Tyler Muth
   * @created ???
   * @param p_log_id logger_logs.id to reference
   * @param p_item_type Either the g_apex_item_type_... type or just the APEX page number for a specific page. It is assumed that it has been validated by the time it hits here.
   * @param p_log_null_items If set to false, null values won't be logged
   */
  procedure snapshot_apex_items(
    p_log_id in logger_logs.id%type,
    p_item_type in varchar2,
    p_log_null_items in boolean)
  is
    l_app_session number;
    l_app_id number;
    l_log_null_item_yn varchar2(1);
    l_item_type varchar2(30) := upper(p_item_type);
    l_item_type_page_id number;
  begin
    $if $$no_op $then
      null;
    $else
      $if $$apex $then
        l_app_session := v('APP_SESSION');
        l_app_id := v('APP_ID');

        l_log_null_item_yn := 'N';
        if p_log_null_items then
          l_log_null_item_yn := 'Y';
        end if;

        if logger.is_number(l_item_type) then
          l_item_type_page_id := to_number(l_item_type);
        end if;

        insert into logger_logs_apex_items(log_id,app_session,item_name,item_value)
        select p_log_id, l_app_session, item_name, item_value
        from (
          -- Application items
          select 1 app_page_seq, 0 page_id, item_name, v(item_name) item_value
          from apex_application_items
          where 1=1
            and application_id = l_app_id
            and l_item_type in (logger.g_apex_item_type_all, logger.g_apex_item_type_app)
          union all
          -- Application page items
          select 2 app_page_seq, page_id, item_name, v(item_name) item_value
          from apex_application_page_items
          where 1=1
            and application_id = l_app_id
            and (
              1=2
              or l_item_type in (logger.g_apex_item_type_all, logger.g_apex_item_type_page)
              or (l_item_type_page_id is not null and l_item_type_page_id = page_id)
            )
          )
        where 1=1
          and (l_log_null_item_yn = 'Y' or item_value is not null)
        order by app_page_seq, page_id, item_name;

      $end -- $if $$apex $then

      null; -- Keep this in place incase APEX is not compiled
    $end -- $$no_op
  end snapshot_apex_items;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #46: Added plugin support
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_error(
    p_text in varchar2 default null,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
    l_proc_name varchar2(100);
    l_lineno varchar2(100);
    l_text varchar2(32767);
    l_call_stack varchar2(4000);
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_error) then
        get_debug_info(
          p_callstack => dbms_utility.format_call_stack,
          o_unit => l_proc_name,
          o_lineno => l_lineno);

        l_call_stack := dbms_utility.format_error_stack() || gc_line_feed || dbms_utility.format_error_backtrace;

        if p_text is not null then
          l_text := p_text || gc_line_feed || gc_line_feed;
        end if;

        l_text := l_text || dbms_utility.format_error_stack();

        l_extra := set_extra_with_params(p_extra => p_extra, p_params => p_params);

        ins_logger_logs(
          p_unit_name => upper(l_proc_name) ,
          p_scope => p_scope ,
          p_logger_level => logger.g_error,
          p_extra => l_extra,
          p_text => l_text,
          p_call_stack => l_call_stack,
          p_line_no => l_lineno,
          po_id => g_log_id);

        -- Plugin
        $if $$logger_plugin_error $then

          if not g_in_plugin_error then
            g_plug_logger_log_error.logger_level := logger.g_error;
            g_plug_logger_log_error.id := g_log_id;

            $if $$logger_debug $then
              dbms_output.put_line('Starting call to run_plugin error');
            $end

            run_plugin(p_logger_log => g_plug_logger_log_error);
          end if; -- not g_in_plugin_error
        $end

      end if; -- ok_to_log
    $end
  end log_error;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_permanent(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_permanent) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_permanent,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params
        );
      end if;
    $end
  end log_permanent;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_warning(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_warning) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_warning,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log_warning;


  /**
   * Wrapper for log_warning
   *
   * Notes:
   *  - #80
   *
   * Related Tickets:
   *  -
   *
   * @author Martin D'Souza
   * @created 9-9-Mar-2015
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_warn(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    logger.log_warning(
      p_text => p_text,
      p_scope => p_scope,
      p_extra => p_extra,
      p_params => p_params
    );
  end log_warn;

  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_information(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_information) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_information,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log_information;


  /**
   * Wrapper for short call to log_information
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #80
   *
   * @author Martin D'Souza
   * @created 9-Mar-2015
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log_info(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin
    logger.log_information(
      p_text => p_text,
      p_scope => p_scope,
      p_extra => p_extra,
      p_params => p_params
    );
  end log_info;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_extra
   * @param p_params
   */
  procedure log(
    p_text in varchar2,
    p_scope in varchar2 default null,
    p_extra in clob default null,
    p_params in tab_param default logger.gc_empty_tab_param)
  is
  begin

    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        log_internal(
          p_text => p_text,
          p_log_level => logger.g_debug,
          p_scope => p_scope,
          p_extra => p_extra,
          p_callstack => dbms_utility.format_call_stack,
          p_params => p_params);
      end if;
    $end
  end log;


  /**
   * Get list of CGI values
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_show_null
   * @return CGI values
   */
  function get_cgi_env(
    p_show_null   in boolean default false)
    return clob
  is
    l_cgienv clob;

    $if $$no_op is null or not $$no_op $then
      procedure append_cgi_env(
        p_name    in varchar2,
        p_val   in varchar2)
      is
        r_pad number := 30;
      begin
        if p_show_null or p_val is not null then
          l_cgienv := l_cgienv || rpad(p_name,r_pad,' ')||': '||p_val||gc_cflf;
        end if;
      end append_cgi_env;
    $end

  begin
    $if $$no_op $then
      return null;
    $else
      for i in 1..nvl(owa.num_cgi_vars,0) loop
        append_cgi_env(
          p_name      => owa.cgi_var_name(i),
          p_val       => owa.cgi_var_val(i));

      end loop;

      return l_cgienv;
    $end
  end get_cgi_env;


  /**
   * Logs system environment variables
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   * - #29 Support for definging level
   *
   * @author Tyler Muth
   * @created ???
   * @param p_detail_level USER, ALL, NLS, INSTANCE
   * @param p_show_null
   * @param p_scope
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_userenv(
    p_detail_level in varchar2 default 'USER',-- ALL, NLS, USER, INSTANCE,
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null)
  is
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_extra := get_sys_context(
          p_detail_level => p_detail_level,
          p_vertical => true,
          p_show_null => p_show_null);

        log_internal(
          p_text => 'USERENV values stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_sys_context),
          p_scope => p_scope,
          p_extra => l_extra);
      end if;
    $end
  end log_userenv;


  /**
   * Logs CGI environment variables
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_show_null
   * @param p_scope
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_cgi_env(
    p_show_null in boolean default false,
    p_scope in logger_logs.scope%type default null,
    p_level in logger_logs.logger_level%type default null)
  is
    l_extra clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_extra := get_cgi_env(p_show_null    => p_show_null);
        log_internal(
          p_text => 'CGI ENV values stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_sys_context),
          p_scope => p_scope,
          p_extra => l_extra);
      end if;
    $end
  end log_cgi_env;


  /**
   * Logs character codes for given string
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_show_common_codes
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_character_codes(
    p_text in varchar2,
    p_scope in logger_logs.scope%type default null,
    p_show_common_codes in boolean default true,
    p_level in logger_logs.logger_level%type default null)
  is
    l_error varchar2(4000);
    l_dump clob;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then
        l_dump := get_character_codes(p_text,p_show_common_codes);

        log_internal(
          p_text => 'GET_CHARACTER_CODES output stored in the EXTRA column',
          p_log_level => nvl(p_level, logger.g_debug),
          p_scope => p_scope,
          p_extra => l_dump);
      end if;
    $end
  end log_character_codes;


  /**
   * Log's APEX items
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #115 Only log not-null values
   *  - #29 Support for definging level
   *  - #54: Add p_item_type
   *
   * @author Tyler Muth
   * @created ???
   * @param p_text
   * @param p_scope
   * @param p_item_type Either the g_apex_item_type_... type or just the APEX page number for a specific page.
   * @param p_log_null_items If set to false, null values won't be logged
   * @param p_level Highest level to run at (default logger.g_debug). Example. If you set to logger.g_error it will work when both in DEBUG and ERROR modes. However if set to logger.g_debug(default) will not store values when level is set to ERROR.
   */
  procedure log_apex_items(
    p_text in varchar2 default 'Log APEX Items',
    p_scope in logger_logs.scope%type default null,
    p_item_type in varchar2 default logger.g_apex_item_type_all,
    p_log_null_items in boolean default true,
    p_level in logger_logs.logger_level%type default null)
  is
    l_error varchar2(4000);
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(nvl(p_level, logger.g_debug)) then

        $if $$apex $then
          -- Validate p_item_type
          assert(
            p_condition => upper(p_item_type) in (logger.g_apex_item_type_all, logger.g_apex_item_type_app, logger.g_apex_item_type_page) or logger.is_number(p_item_type),
            p_message => logger.sprintf('APEX Item Scope was set to %s. Must be %s, %s, %s, or page number', p_item_type, logger.g_apex_item_type_all, logger.g_apex_item_type_page, logger.g_apex_item_type_page));

          log_internal(
            p_text => p_text,
            p_log_level => nvl(p_level, logger.g_apex),
            p_scope => p_scope);

          snapshot_apex_items(
            p_log_id => g_log_id,
            p_item_type => upper(p_item_type),
            p_log_null_items => p_log_null_items);
        $else
          l_error := 'Error! Logger is not configured for APEX yet. ';

          log_internal(
            p_text => l_error,
            p_log_level => logger.g_apex,
            p_scope => p_scope);
        $end
      end if;
    $end
    commit;
  end log_apex_items;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Use localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_log_in_table
   */
  procedure time_start(
    p_unit in varchar2,
    p_log_in_table in boolean default true)
  is
    l_proc_name varchar2(100);
    l_text varchar2(4000);
    l_pad varchar2(100);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        g_running_timers := g_running_timers + 1;

        if g_running_timers > 1 then
          -- Use 'a' since lpad requires a value to pad
          l_pad := replace(lpad('a',logger.g_running_timers,'>')||' ', 'a', null);
        end if;

        g_proc_start_times(p_unit) := localtimestamp;

        l_text := l_pad||'START: '||p_unit;

        if p_log_in_table then
          ins_logger_logs(
            p_unit_name => p_unit ,
            p_logger_level => g_timing,
            p_text =>l_text,
            po_id => g_log_id);
        end if;
      end if;
    $end
  end time_start;

  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73: Remove additional timer decrement since it was already happening in function time_stop
   *
   * @author Tyler Muth
   * @created ???
   * @param p_scope
   * @param p_unit
   */
  procedure time_stop(
    p_unit in varchar2,
    p_scope in varchar2 default null)
  is
    l_time_string varchar2(50);
    l_text varchar2(4000);
    l_pad varchar2(100);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then

          if g_running_timers > 1 then
            -- Use 'a' since lpad requires a value to pad
            l_pad := replace(lpad('a',logger.g_running_timers,'>')||' ', 'a', null);
          end if;

          --l_time_string := rtrim(regexp_replace(systimestamp-(g_proc_start_times(p_unit)),'.+?[[:space:]](.*)','\1',1,0),0);
          -- Function time_stop will decrement the timers and pop the name from the g_proc_start_times array
          l_time_string := time_stop(
            p_unit => p_unit,
            p_log_in_table => false);

          l_text := l_pad||'STOP : '||p_unit ||' - '||l_time_string;

          ins_logger_logs(
            p_unit_name => p_unit,
            p_scope => p_scope ,
            p_logger_level => g_timing,
            p_text =>l_text,
            po_id => g_log_id);
        end if;
      end if;
    $end
  end time_stop;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Trim timezone from systimestamp to localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_scope
   * @param p_log_in_table
   * @return Timer string
   */
  function time_stop(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table IN boolean default true)
    return varchar2
  is
    l_time_string varchar2(50);
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then

          l_time_string := rtrim(regexp_replace(localtimestamp - (g_proc_start_times(p_unit)),'.+?[[:space:]](.*)','\1',1,0),0);

          g_proc_start_times.delete(p_unit);
          g_running_timers := g_running_timers - 1;

          if p_log_in_table then
            ins_logger_logs(
              p_unit_name => p_unit,
              p_scope => p_scope ,
              p_logger_level => g_timing,
              p_text => l_time_string,
              po_id => g_log_id);
          end if;

          return l_time_string;

        end if;
      end if;
    $end
  end time_stop;


  /**
   *
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #73/#75: Trim timezone from systimestamp to localtimestamp
   *
   * @author Tyler Muth
   * @created ???
   * @param p_unit
   * @param p_scope
   * @param p_log_in_table
   * @return Timer in seconds
   */
  function time_stop_seconds(
    p_unit in varchar2,
    p_scope in varchar2 default null,
    p_log_in_table in boolean default true
    )
    return number
  is
    l_time_string varchar2(50);
    l_seconds number;
    l_interval interval day to second;

  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        if g_proc_start_times.exists(p_unit) then
          l_interval := localtimestamp - (g_proc_start_times(p_unit));
          l_seconds := extract(day from l_interval) * 86400 + extract(hour from l_interval) * 3600 + extract(minute from l_interval) * 60 + extract(second from l_interval);

          g_proc_start_times.delete(p_unit);
          g_running_timers := g_running_timers - 1;

          if p_log_in_table then
            ins_logger_logs(
              p_unit_name => p_unit,
              p_scope => p_scope ,
              p_logger_level => g_timing,
              p_text => l_seconds,
              po_id => g_log_id);
          end if;

          return l_seconds;

        end if;
      end if;
    $end
  end time_stop_seconds;


  /**
   * Resets all timers
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure time_reset
  is
  begin
    $if $$no_op $then
      null;
    $else
      if ok_to_log(logger.g_debug) then
        g_running_timers := 0;
        g_proc_start_times.delete;
      end if;
    $end
  end time_reset;

  /**
   * Returns Global or User preference
   * User preference is only valid for LEVEL and INCLUDE_CALL_STACK
   *  - If a user setting exists, it will be returned, if not the system level preference will be return
   *
   * Updates
   *  - 2.0.0: Added user preference support
   *  - 2.1.2: Fixed issue when calling set_level with the same client_id multiple times
   *
   * Related Tickets:
   *  - #127: Added logger_prefs.pref_type
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_pref_name
   * @param p_pref_type Namespace for preference
   */
  function get_pref(
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_type in logger_prefs.pref_type%type default logger.g_pref_type_logger)
    return varchar2
    $if not dbms_db_version.ver_le_10_2  $then
      result_cache
      $if $$no_op is null or not $$no_op $then
        relies_on (logger_prefs, logger_prefs_by_client_id)
      $end
    $end
  is
    l_scope varchar2(30) := 'get_pref';
    l_pref_value logger_prefs.pref_value%type;
    l_client_id logger_prefs_by_client_id.client_id%type;
    l_pref_name logger_prefs.pref_name%type := upper(p_pref_name);
    l_pref_type logger_prefs.pref_type%type := upper(p_pref_type);
  begin

    $if $$no_op $then
      return null;
    $else
      $if $$logger_debug $then
        dbms_output.put_line(l_scope || ' select pref');
      $end

      l_client_id := sys_context('userenv','client_identifier');

      select pref_value
      into l_pref_value
      from (
        select pref_value, row_number () over (order by rank) rn
        from (
          -- Client specific logger levels trump system level logger level
          select
            case
              when l_pref_name = logger.gc_pref_level then logger_level
              when l_pref_name = logger.gc_pref_include_call_stack then include_call_stack
            end pref_value,
            1 rank
          from logger_prefs_by_client_id
          where 1=1
            and client_id = l_client_id
            -- Only try to get prefs at a client level if pref is in LEVEL or INCLUDE_CALL_STACK
            and l_client_id is not null
            -- #127
            -- Prefs by client aren't available for custom prefs right now
            -- Only need to search this table if p_pref_type is LOGGER
            and l_pref_type = logger.g_pref_type_logger
            and l_pref_name in (logger.gc_pref_level, logger.gc_pref_include_call_stack)
          union
          -- System level configuration
          select pref_value, 2 rank
          from logger_prefs
          where 1=1
            and pref_name = l_pref_name
            and pref_type = l_pref_type
        )
      )
      where rn = 1;
      return l_pref_value;
    $end

  exception
    when no_data_found then
      return null;
    when others then
      raise;
  end get_pref;


  /**
   * Sets a preference
   * If it does not exist, it will insert one
   *
   * Notes:
   *  - Does not support setting system preferences
   *
   * Related Tickets:
   *  - #127
   *
   * @author Alex Nuijten / Martin D'Souza
   * @created 24-APR-2015
   * @param p_pref_type
   * @param p_pref_name
   * @param p_pref_value
   */
  procedure set_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type,
    p_pref_value in logger_prefs.pref_value%type)
  as
    l_pref_type logger_prefs.pref_type%type := trim(upper(p_pref_type));
    l_pref_name logger_prefs.pref_name%type := trim(upper(p_pref_name));
  begin

    $if $$no_op $then
      null;
    $else
      if l_pref_type = logger.g_pref_type_logger then
        raise_application_error(-20001, 'Can not set ' || l_pref_type || '. Reserved for Logger');
      end if;

      merge into logger_prefs p
      using (select l_pref_type pref_type, l_pref_name pref_name, p_pref_value pref_value
             from dual) args
      on ( 1=1
        and p.pref_type = args.pref_type
        and p.pref_name = args.pref_name)
      when matched then
        update
        set p.pref_value =  args.pref_value
      when not matched then
        insert (pref_type, pref_name ,pref_value)
      values
        (args.pref_type, args.pref_name ,args.pref_value);
    $end -- $no_op

  end set_pref;

  /**
   * Removes a Preference
   *
   * Notes:
   *  - Does not support setting system preferences
   *
   * Related Tickets:
   *  - #127
   *
   * @author Alex Nuijten / Martin D'Souza
   * @created 30-APR-2015
   *
   * @param p_pref_type
   * @param p_pref_name
   */
  procedure del_pref(
    p_pref_type in logger_prefs.pref_type%type,
    p_pref_name in logger_prefs.pref_name%type)
  is
    l_pref_type logger_prefs.pref_type%type := trim(upper(p_pref_type));
    l_pref_name logger_prefs.pref_name%type := trim(upper (p_pref_name));
  begin
    $if $$no_op $then
      null;
    $else
      if l_pref_type = logger.g_pref_type_logger then
        raise_application_error(-20001, 'Can not delete ' || l_pref_type || '. Reserved for Logger');
      end if;

      delete from logger_prefs
      where 1=1
        and pref_type = l_pref_type
        and pref_name = l_pref_name;
    $end
  end del_pref;


  /**
   * Purges logger_logs data
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #48 Support for overloading
   *
   * @author Martin D'Souza
   * @created 14-Jun-2014
   * @param p_purge_after_days
   * @param p_purge_min_level
   */
  procedure purge(
    p_purge_after_days in number default null,
    p_purge_min_level in number)

  is
    $if $$no_op is null or not $$no_op $then
      l_purge_after_days number := nvl(p_purge_after_days,get_pref(logger.gc_pref_purge_after_days));
    $end
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else

      if admin_security_check then
        delete
          from logger_logs
         where logger_level >= p_purge_min_level
           and time_stamp < systimestamp - NUMTODSINTERVAL(l_purge_after_days, 'day')
           and logger_level > g_permanent;
      end if;
    $end
    commit;
  end purge;


  /**
   * Wrapper for Purge (to accept number for purge_min_level)
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_purge_after_days
   * @param p_purge_min_level
   */
  procedure purge(
    p_purge_after_days in varchar2 default null,
    p_purge_min_level in varchar2 default null)

  is
  begin
    $if $$no_op $then
      null;
    $else
      purge(
        p_purge_after_days => to_number(p_purge_after_days),
        p_purge_min_level => convert_level_char_to_num(nvl(p_purge_min_level,get_pref(logger.gc_pref_purge_min_level))));
    $end
  end purge;


  /**
   * Purges all records that aren't marked as permanent
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure purge_all
  is
    l_purge_level number  := g_permanent;
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      if admin_security_check then
        delete from logger_logs where logger_level > l_purge_level;
      end if;
    $end
    commit;
  end purge_all;


  /**
   * Displays Logger's current status
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   * @param p_output_format SQL-DEVELOPER | HTML | DBMS_OUPUT
   */
  procedure status(
    p_output_format in varchar2 default null) -- SQL-DEVELOPER | HTML | DBMS_OUPUT
  is
    l_debug varchar2(50) := 'Disabled';
    l_apex varchar2(50) := 'Disabled';
    l_flashback varchar2(50) := 'Disabled';
    dummy varchar2(255);
    l_output_format varchar2(30);
    l_version varchar2(20);
    l_client_identifier logger_prefs_by_client_id.client_id%type;

    -- For current client info
    l_cur_logger_level logger_prefs_by_client_id.logger_level%type;
    l_cur_include_call_stack logger_prefs_by_client_id.include_call_stack%type;
    l_cur_expiry_date logger_prefs_by_client_id.expiry_date%type;

    procedure display_output(
      p_name  in varchar2,
      p_value in varchar2)
    is
    begin
      if l_output_format = 'SQL-DEVELOPER' then
        dbms_output.put_line('<pre>'||rpad(p_name,25)||': <strong>'||p_value||'</strong></pre>');
      elsif l_output_format = 'HTTP' then
        htp.p('<br />'||p_name||': <strong>'||p_value||'</strong>');
      else
        dbms_output.put_line(rpad(p_name,25)||': '||p_value);
      end if;
    end display_output;

  begin
    if p_output_format is null then
      begin
        dummy := owa_util.get_cgi_env('HTTP_HOST');
        l_output_format := 'HTTP';
      exception
        when value_error then
        l_output_format := 'DBMS_OUTPUT';
        dbms_output.enable;
      end;
    else
      l_output_format := p_output_format;
    end if;

    display_output('Project Home Page','https://github.com/oraopensource/logger/');

    $if $$no_op $then
      display_output('Debug Level','NO-OP, Logger completely disabled.');
    $else
      $if $$apex $then
        l_apex := 'Enabled';
      $end

      select pref_value
      into l_debug
      from logger_prefs
      where 1=1
        and pref_type = logger.g_pref_type_logger
        and pref_name = logger.gc_pref_level;

      $if $$flashback_enabled $then
        l_flashback := 'Enabled';
      $end

      l_version := get_pref(logger.gc_pref_logger_version);

      display_output('Logger Version',l_version);
      display_output('Debug Level',l_debug);
      display_output('Capture Call Stack',get_pref(logger.gc_pref_include_call_stack));
      display_output('Protect Admin Procedures',get_pref(logger.gc_pref_protect_admin_procs));
      display_output('APEX Tracing',l_apex);
      display_output('SCN Capture',l_flashback);
      display_output('Min. Purge Level',get_pref(logger.gc_pref_purge_min_level));
      display_output('Purge Older Than',get_pref(logger.gc_pref_purge_after_days)||' days');
      display_output('Pref by client_id expire hours',get_pref(logger.gc_pref_client_id_expire_hours)||' hours');
      $if $$rac_lt_11_2  $then
        display_output('RAC pre-11.2 Code','TRUE');
      $end

      -- #46 Only display plugins if enabled
      $if $$logger_plugin_error $then
        display_output('PLUGIN_FN_ERROR',get_pref(logger.gc_pref_plugin_fn_error));
      $end

      -- #64
      $if $$logger_debug $then
        display_output('LOGGER_DEBUG',get_pref(logger.gc_pref_logger_debug) || '   *** SHOULD BE TURNED OFF!!! SET TO FALSE ***');
      $end


      l_client_identifier := sys_context('userenv','client_identifier');
      if l_client_identifier is not null then
        -- Since the client_identifier exists, try to see if there exists a record session sepecfic logging level
        -- Note: this query should only return 0..1 rows
        begin
          select logger_level, include_call_stack, expiry_date
          into l_cur_logger_level, l_cur_include_call_stack, l_cur_expiry_date
          from logger_prefs_by_client_id
          where client_id = l_client_identifier;

          display_output('Client Identifier', l_client_identifier);
          display_output('Client - Debug Level', l_cur_logger_level);
          display_output('Client - Call Stack', l_cur_include_call_stack);
          display_output('Client - Expiry Date', logger.tochar(l_cur_expiry_date));
        exception
          when no_data_found then
            null; -- No client specific logging set
          when others then
            raise;
        end;
      end if; -- client_identifier exists

      display_output('For all client info see', 'logger_prefs_by_client_id');

    $end
  end status;


  /**
   * Sets the logger level
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  - #60 Allow security check to be bypassed for client specific logging level
   *  - #48 Allow of numbers to be passed in p_level. Did not overload (see ticket comments as to why)
   *  - #110 Clear context values when level changes globally
   *  - #29 If p_level is deprecated, set to DEBUG
   *
   * @author Tyler Muth
   * @created ???
   *
   * @param p_level Valid values: OFF,PERMANENT,ERROR,WARNING,INFORMATION,DEBUG,TIMING
   * @param p_client_id Optional: If defined, will set the level for the given client identifier. If null will affect global settings
   * @param p_include_call_stack Optional: Only valid if p_client_id is defined Valid values: TRUE, FALSE. If not set will use the default system pref in logger_prefs.
   * @param p_client_id_expire_hours If p_client_id, expire after number of hours. If not defined, will default to system preference PREF_BY_CLIENT_ID_EXPIRE_HOURS
   */
  procedure set_level(
    p_level in varchar2 default logger.g_debug_name,
    p_client_id in varchar2 default null,
    p_include_call_stack in varchar2 default null,
    p_client_id_expire_hours in number default null
  )
  is
    l_level varchar2(20);
    l_ctx varchar2(2000);
    l_include_call_stack varchar2(255);
    l_client_id_expire_hours number;
    l_expiry_date logger_prefs_by_client_id.expiry_date%type;

    l_id logger_logs.id%type;
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      raise_application_error (-20000,
          'Either the NO-OP version of Logger is installed or it is compiled for NO-OP,  so you cannot set the level.');
    $else
      l_level := replace(upper(p_level),' ');

      if is_number(p_str => l_level) then
        l_level := convert_level_num_to_char(p_level => p_level);
      end if;

      l_include_call_stack := nvl(trim(upper(p_include_call_stack)), get_pref(logger.gc_pref_include_call_stack));

      assert(
          l_level in (g_off_name, g_permanent_name, g_error_name, g_warning_name, g_information_name, g_debug_name, g_timing_name, g_sys_context_name, g_apex_name),
        '"LEVEL" must be one of the following values: ' ||
          g_off_name || ', ' || g_permanent_name || ', ' || g_error_name || ', ' || g_warning_name || ', ' ||
          g_information_name || ', ' || g_debug_name || ', ' || g_timing_name || ', ' ||
          g_sys_context_name || ', ' || g_apex_name );
      assert(l_include_call_stack in ('TRUE', 'FALSE'), 'l_include_call_stack must be TRUE or FALSE');

      -- #60 Allow security check to be bypassed for client specific logging level
      if p_client_id is not null or admin_security_check then
        l_ctx := 'Host: '||sys_context('USERENV','HOST');
        l_ctx := l_ctx || ', IP: '||sys_context('USERENV','IP_ADDRESS');
        l_ctx := l_ctx || ', TERMINAL: '||sys_context('USERENV','TERMINAL');
        l_ctx := l_ctx || ', OS_USER: '||sys_context('USERENV','OS_USER');
        l_ctx := l_ctx || ', CURRENT_USER: '||sys_context('USERENV','CURRENT_USER');
        l_ctx := l_ctx || ', SESSION_USER: '||sys_context('USERENV','SESSION_USER');

        -- #29 Deprecate old levels. Log and set to DEBUG
        if l_level in (logger.g_apex_name, logger.g_sys_context_name, logger.g_timing_name)  then
          logger.ins_logger_logs(
            p_logger_level => logger.g_warning,
            p_text =>
              logger.sprintf('Logger level: %s1 is deprecated. Set for client_id %s2. Automatically setting to %s3', l_level, nvl(p_client_id, '<global>'), logger.g_debug_name),
            po_id => l_id);

          l_level := logger.g_debug_name;
        end if;


        -- Separate updates/inserts for client_id or global settings
        if p_client_id is not null then
          l_client_id_expire_hours := nvl(p_client_id_expire_hours, get_pref(logger.gc_pref_client_id_expire_hours));
          l_expiry_date := sysdate + l_client_id_expire_hours/24;

          merge into logger_prefs_by_client_id ci
          using (select p_client_id client_id from dual) s
            on (ci.client_id = s.client_id)
          when matched then update
            set logger_level = l_level,
              include_call_stack = l_include_call_stack,
              expiry_date = l_expiry_date,
              created_date = sysdate
          when not matched then
            insert(ci.client_id, ci.logger_level, ci.include_call_stack, ci.created_date, ci.expiry_date)
            values(p_client_id, l_level, l_include_call_stack, sysdate, l_expiry_date)
          ;

        else
          -- Global settings
          update logger_prefs
          set pref_value = l_level
          where 1=1
            and pref_type = logger.g_pref_type_logger
            and pref_name = logger.gc_pref_level;
        end if;

        -- #110 Need to reset all contexts so that level is reset for sessions where client_identifier is defined
        -- This is required for global changes since sessions with client_identifier set won't be properly updated.
        if p_client_id is null then
          logger.null_global_contexts;
        end if;

        logger.save_global_context(
          p_attribute => gc_ctx_attr_level,
          p_value => logger.convert_level_char_to_num(l_level),
          p_client_id => p_client_id); -- Note: if p_client_id is null then it will set for global`

        -- Manual insert to ensure that data gets logged, regardless of logger_level
        logger.ins_logger_logs(
          p_logger_level => logger.g_information,
          p_text => 'Log level set to ' || l_level || ' for client_id: ' || nvl(p_client_id, '<global>') || ', include_call_stack=' || l_include_call_stack || ' by ' || l_ctx,
          po_id => l_id);

      end if; -- p_client_id is not null or admin_security_check
    $end
    commit;
  end set_level;


  /**
   * Unsets a logger level for a given client_id
   * This will only unset for client specific logger levels
   * Note: An explicit commit will occur in this procedure
   *
   * @author Martin D'Souza
   * @created 6-Apr-2013
   *
   * @param p_client_id Client identifier (case sensitive) to unset logger level in.
   */
  procedure unset_client_level(p_client_id in varchar2)
  as
    pragma autonomous_transaction;
  begin
    $if $$no_op $then
      null;
    $else
      assert(p_client_id is not null, 'p_client_id is a required value');

      -- Remove from client specific table
      delete from logger_prefs_by_client_id
      where client_id = p_client_id;

      -- Remove context values
      dbms_session.clear_context(
       namespace => g_context_name,
       client_id => p_client_id,
       attribute => gc_ctx_attr_level);

      dbms_session.clear_context(
       namespace => g_context_name,
       client_id => p_client_id,
       attribute => gc_ctx_attr_include_call_stack);

    $end

    commit;
  end unset_client_level;


  /**
   * Unsets client_level that are stale (i.e. past thier expiry date)
   *
   * @author Martin D'Souza
   * @created 7-Apr-2013
   *
   * @param p_unset_after_hours If null then preference UNSET_CLIENT_ID_LEVEL_AFTER_HOURS
   */
  procedure unset_client_level
  as
  begin
    $if $$no_op $then
      null;
    $else
      for x in (
        select client_id
        from logger_prefs_by_client_id
        where sysdate > expiry_date) loop

        unset_client_level(p_client_id => x.client_id);
      end loop;
    $end
  end unset_client_level;


  /**
   * Unsets all client specific preferences
   * An implicit commit will occur as unset_client_level makes a commit
   *
   * @author Martin D'Souza
   * @created 7-Apr-2013
   *
   */
  procedure unset_client_level_all
  as
  begin
    $if $$no_op $then
      null;
    $else
      for x in (select client_id from logger_prefs_by_client_id) loop
        unset_client_level(p_client_id => x.client_id);
      end loop;
    $end
  end unset_client_level_all;


  /**
   * Displays commonly used dbms_output SQL*Plus settings
   *
   * Notes:
   *  -
   *
   * Related Tickets:
   *  -
   *
   * @author Tyler Muth
   * @created ???
   */
  procedure sqlplus_format
  is
  begin
    execute immediate 'begin dbms_output.enable(1000000); end;';
    dbms_output.put_line('set linesize 200');
    dbms_output.put_line('set pagesize 100');

    dbms_output.put_line('column id format 999999');
    dbms_output.put_line('column text format a75');
    dbms_output.put_line('column call_stack format a100');
    dbms_output.put_line('column extra format a100');

  end sqlplus_format;

  /**
   * Converts parameter to varchar2
   *
   * Notes:
   *  - As this function could be useful for non-logging purposes will not apply a NO_OP to it for conditional compilation
   *  - Need to call this tochar instead of to_char since there will be a conflict when calling it
   *
   * Related Tickets:
   *  - #68
   *
   * @author Martin D'Souza
   * @created 07-Jun-2014
   * @param p_value
   * @return varchar2 value for p_value
   */
  function tochar(
    p_val in number)
    return varchar2
  as
  begin
    return to_char(p_val);
  end tochar;

  function tochar(
    p_val in date)
    return varchar2
  as
  begin
    return to_char(p_val, gc_date_format);
  end tochar;

  function tochar(
    p_val in timestamp)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_format);
  end tochar;

  function tochar(
    p_val in timestamp with time zone)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_tz_format);
  end tochar;

  function tochar(
    p_val in timestamp with local time zone)
    return varchar2
  as
  begin
    return to_char(p_val, gc_timestamp_tz_format);
  end tochar;

  -- #119: Return null for null booleans
  function tochar(
    p_val in boolean)
    return varchar2
  as
  begin
    return case p_val when true then 'TRUE' when false then 'FALSE' else null end;
  end tochar;



  -- Handle Parameters

  /**
   * Append parameter to table of parameters
   * Nothing is actually logged in this procedure
   * This procedure is overloaded
   *
   * Related Tickets:
   *  - #67: Updated to reference to_char functions
   *
   * @author Martin D'Souza
   * @created 19-Jan-2013
   *
   * @param p_params Table of parameters (param will be appended to this)
   * @param p_name Name
   * @param p_val Value in its format. Will be converted to string
   */
  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in varchar2
  )
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      l_param.name := p_name;
      l_param.val := p_val;
      p_params(p_params.count + 1) := l_param;
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in number)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in date)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with time zone)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in timestamp with local time zone)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;

  procedure append_param(
    p_params in out nocopy logger.tab_param,
    p_name in varchar2,
    p_val in boolean)
  as
    l_param logger.rec_param;
  begin
    $if $$no_op $then
      null;
    $else
      logger.append_param(p_params => p_params, p_name => p_name, p_val => logger.tochar(p_val => p_val));
    $end
  end append_param;


  /**
   * Handles inserts into LOGGER_LOGS.
   *
   * Replaces trigger for both performance issues and to be a single location for all insert statements
   *
   * autonomous_transaction so commit will be performed after insert
   *
   * @author Martin D'Souza
   * @created 30-Jul-2013
   *
   * Related Issues
   *  - #31: Initial ticket
   *  - #51: Added SID column
   *  - #70: Fixed missing no_op flag
   *  - #109: Fix length check for multibyte characters
   *
   * @param p_logger_level
   * @param p_text
   * @param p_scope
   * @param p_call_stack
   * @param p_unit_name
   * @param p_line_no
   * @param p_extra
   * @param po_id ID entered into logger_logs for this record
   */
  procedure ins_logger_logs(
    p_logger_level in logger_logs.logger_level%type,
    p_text in varchar2 default null, -- Not using type since want to be able to pass in 32767 characters
    p_scope in logger_logs.scope%type default null,
    p_call_stack in logger_logs.call_stack%type default null,
    p_unit_name in logger_logs.unit_name%type default null,
    p_line_no in logger_logs.line_no%type default null,
    p_extra in logger_logs.extra%type default null,
    po_id out nocopy logger_logs.id%type
    )
  as
    pragma autonomous_transaction;

    l_id logger_logs.id%type;
    l_text varchar2(32767) := p_text;
    l_extra logger_logs.extra%type := p_extra;
    l_tmp_clob clob;

  begin
    $if $$no_op $then
      null;
    $else
      -- Using select into to support version older than 11gR1 (see Issue 26)
      select logger_logs_seq.nextval
      into po_id
      from dual;

      -- 2.1.0: If text is > 4000 characters, it will be moved to the EXTRA column (Issue 17)
      $if $$large_text_column $then -- Only check for moving to Clob if small text column
        -- Don't do anything since column supports large text
      $else
        if lengthb(l_text) > 4000 then -- #109 Using lengthb for multibyte characters
          if l_extra is null then
            l_extra := l_text;
          else
            -- Using temp clob for performance purposes: http://www.talkapex.com/2009/06/how-to-quickly-append-varchar2-to-clob.html
            l_tmp_clob := gc_line_feed || gc_line_feed || '*** Content moved from TEXT column ***' || gc_line_feed;
            l_extra := l_extra || l_tmp_clob;
            l_tmp_clob := l_text;
            l_extra := l_extra || l_text;
          end if; -- l_extra is not null

          l_text := 'Text moved to EXTRA column';
        end if; -- length(l_text)
      $end

      insert into logger_logs(
        id, logger_level, text,
        time_stamp, scope, module,
        action,
        user_name,
        client_identifier,
        call_stack, unit_name, line_no ,
        scn,
        extra,
        sid,
        client_info
        )
       values(
         po_id, p_logger_level, l_text,
         systimestamp, lower(p_scope), sys_context('userenv','module'),
         sys_context('userenv','action'),
         nvl($if $$apex $then apex_application.g_user $else user $end,user),
         sys_context('userenv','client_identifier'),
         p_call_stack, upper(p_unit_name), p_line_no,
         null,
         l_extra,
         to_number(sys_context('userenv','sid')),
         sys_context('userenv','client_info')
         );

    $end -- $$NO_OP

    commit;
  end ins_logger_logs;


  /**
   * Does string replacement similar to C's sprintf
   *
   * Notes:
   *  - Uses the following replacement algorithm (in following order)
   *    - Replaces %s<n> with p_s<n>
   *    - Occurrences of %s (no number) are replaced with p_s1..p_s10 in order that they appear in text
   *    - %% is escaped to %
   *  - As this function could be useful for non-logging purposes will not apply a NO_OP to it for conditional compilation
   *
   * Related Tickets:
   *  - #32: Also see #59
   *  - #95: Remove no_op clause
   *
   * @author Martin D'Souza
   * @created 15-Jun-2014
   * @param p_str Messsage to format using %s and %d replacement strings
   * @param p_s1
   * @param p_s2
   * @param p_s3
   * @param p_s4
   * @param p_s5
   * @param p_s6
   * @param p_s7
   * @param p_s8
   * @param p_s9
   * @param p_s10
   * @return p_msg with strings replaced
   */
  function sprintf(
    p_str in varchar2,
    p_s1 in varchar2 default null,
    p_s2 in varchar2 default null,
    p_s3 in varchar2 default null,
    p_s4 in varchar2 default null,
    p_s5 in varchar2 default null,
    p_s6 in varchar2 default null,
    p_s7 in varchar2 default null,
    p_s8 in varchar2 default null,
    p_s9 in varchar2 default null,
    p_s10 in varchar2 default null)
    return varchar2
  as
    l_return varchar2(4000);
    c_substring_regexp constant varchar2(10) := '%s';

  begin
    l_return := p_str;

    -- Replace %s<n> with p_s<n>``
    for i in 1..10 loop
      l_return := regexp_replace(l_return, c_substring_regexp || i,
        case
          when i = 1 then p_s1
          when i = 2 then p_s2
          when i = 3 then p_s3
          when i = 4 then p_s4
          when i = 5 then p_s5
          when i = 6 then p_s6
          when i = 7 then p_s7
          when i = 8 then p_s8
          when i = 9 then p_s9
          when i = 10 then p_s10
          else null
        end,
        1,0,'c');
    end loop;

    $if $$logger_debug $then
      dbms_output.put_line('Before sys.utl_lms: ' || l_return);
    $end

    -- Replace any occurences of %s with p_s<n> (in order) and escape %% to %
    l_return := sys.utl_lms.format_message(l_return,p_s1, p_s2, p_s3, p_s4, p_s5, p_s6, p_s7, p_s8, p_s9, p_s10);

    return l_return;

  end sprintf;


  /**
   * Returns the rec_logger_logs for given logger_level
   * Used for plugin.
   * Not meant to be called by general public, and thus not documented
   *
   * Notes:
   *  - -- FUTURE mdsouza: Add tests for this (#86)
   *
   * Related Tickets:
   *  - #46
   *
   * @author Martin D'Souza
   * @created 11-Mar-2015
   * @param p_logger_level Logger level of plugin wanted to return
   * @return Logger rec based on plugin type
   */
  function get_plugin_rec(
    p_logger_level in logger_logs.logger_level%type)
    return logger.rec_logger_log
  as
  begin

    if p_logger_level = logger.g_error then
      return g_plug_logger_log_error;
    end if;
  end get_plugin_rec;

end logger;
/

PROMPT Recompile biu_logger_prefs after logger.pkb 

alter trigger biu_logger_prefs compile;
PROMPT contexts/logger_context.sql 
declare
	-- the following line is also used in a constant declaration in logger.pkb
	l_ctx_name varchar2(35) := substr(sys_context('USERENV','CURRENT_SCHEMA'),1,23)||'_LOGCTX';
begin
	execute immediate 'create or replace context '||l_ctx_name||' using logger accessed globally';

	merge into logger_prefs p
	using (select 'GLOBAL_CONTEXT_NAME' pref_name, l_ctx_name pref_value, logger.g_pref_type_logger pref_type from dual) d
		on (1=1
			and p.pref_type = d.pref_type
			and p.pref_name = d.pref_name)
	when matched then
		update set p.pref_value = d.pref_value
	when not matched then
		insert (p.pref_name, p.pref_value, p.pref_type)
		values (d.pref_name, d.pref_value, d.pref_type);
end;
/

PROMPT procedures/logger_configure.plb 
create or replace procedure logger_configure
is
  -- Note: The license is defined in the package specification of the logger package
	--
	l_rac_lt_11_2 varchar2(50) := 'FALSE';  -- is this a RAC instance less than 11.2, no GAC support

  l_apex varchar2(50) := 'FALSE';
  tbl_not_exist exception;
  pls_pkg_not_exist exception;

  l_text_data_length user_tab_columns.data_length%type;
  l_large_text_column varchar2(50);

  l_sql varchar2(32767);
  l_variables varchar2(1000) := ' ';
  l_dummy number;
  l_flashback varchar2(50) := 'FALSE';
  l_utl_lms varchar2(5) := 'FALSE';

  pragma exception_init(tbl_not_exist, -942);
  pragma exception_init(pls_pkg_not_exist, -06550);

	l_version constant number  := dbms_db_version.version + (dbms_db_version.release / 10);
  l_pref_value logger_prefs.pref_Value%type;
  l_logger_debug boolean;

	l_pref_type_logger logger_prefs.pref_type%type;
begin

  -- Check to see if we are in a RAC Database, 11.1 or lower.
  --
  -- Tyler to check if this works
  if dbms_utility.is_cluster_database then
    l_rac_lt_11_2 := 'TRUE';
  else
    l_rac_lt_11_2 := 'FALSE';
  end if;

  if l_version >= 11.2 then
    l_rac_lt_11_2 := 'FALSE';
  end if;

  l_variables := 'RAC_LT_11_2:'||l_rac_lt_11_2||',';


  -- Check lenth of TEXT size (this is for future 12c 32767 integration
  -- In support of Issue #17 and future proofing for #30
  select data_length
  into l_text_data_length
  from user_tab_columns
  where 1=1
    and table_name = 'LOGGER_LOGS'
    and column_name = 'TEXT';

  if l_text_data_length > 4000 then
    l_large_text_column := 'TRUE';
  else
    l_large_text_column := 'FALSE';
  end if;
  l_variables := l_variables||'LARGE_TEXT_COLUMN:'||l_large_text_column||',';


  -- Is APEX installed ?
  --
  begin
    execute immediate 'select 1 from apex_application_items where rownum = 1' into l_dummy;

    l_apex := 'TRUE';
  exception
    when tbl_not_exist then
      l_apex := 'FALSE';
    when no_data_found then
      l_apex := 'TRUE';
  end;

  l_variables := l_variables||'APEX:'||l_apex||',';


  -- Can we call dbms_flashback to get the currect System Commit Number?
  --
  begin
    execute immediate 'begin :d := dbms_flashback.get_system_change_number; end; ' using out l_dummy;

    l_flashback := 'TRUE';
  exception when pls_pkg_not_exist then
    l_flashback := 'FALSE';
  end;

  l_variables := l_variables||'FLASHBACK_ENABLED:'||l_flashback||',';


  -- #64: Support to run Logger in debug mode

	-- #127
	-- Since this procedure will recompile Logger, if it directly references a variable in Logger
	-- It will lock itself while trying to recompile
	-- Work around is to pre-store the variable using execute immediate
	execute immediate 'begin :x := logger.g_pref_type_logger; end;' using out l_pref_type_logger;

  select lp.pref_value
  into l_pref_value
  from logger_prefs lp
  where 1=1
		and lp.pref_type = upper(l_pref_type_logger)
    and lp.pref_name = 'LOGGER_DEBUG';
  l_variables := l_variables || 'LOGGER_DEBUG:' || l_pref_value||',';

  l_logger_debug := false;
  if upper(l_pref_value) = 'TRUE' then
    l_logger_debug := true;
  end if;


  -- #46
  -- Handle plugin settings
-- Set for each plugin type
  for x in (
    select
      'LOGGER_' ||
      regexp_replace(lp.pref_name, '^PLUGIN_FN_', 'PLUGIN_') || ':' ||
      decode(nvl(upper(lp.pref_value), 'NONE'), 'NONE', 'FALSE', 'TRUE') ||
      ',' var
    from logger_prefs lp
    where 1=1
			and lp.pref_type = l_pref_type_logger
      and lp.pref_name like 'PLUGIN_FN%'
  ) loop
    l_variables := l_variables || x.var;
  end loop;


  l_variables := rtrim(l_variables,',');
  if l_logger_debug then
    dbms_output.put_line('l_variables: ' || l_variables);
  end if;


	-- Recompile Logger
 	l_sql := q'!alter package logger compile body PLSQL_CCFLAGS='%VARIABLES%' reuse settings!';
	l_sql := replace(l_sql, '%VARIABLES%', l_variables);
	execute immediate l_sql;

  -- #31: Dropped trigger
	-- l_sql := q'[alter trigger BI_LOGGER_LOGS compile PLSQL_CCFLAGS=']'||l_variables||q'[' reuse settings]';
	-- execute immediate l_sql;

  -- -- TODO mdsouza: 3.1.1 org l_sql := q'!alter trigger biu_logger_prefs compile PLSQL_CCFLAGS='CURRENTLY_INSTALLING:FALSE'!';
  l_sql := q'!alter trigger biu_logger_prefs compile!';
  execute immediate l_sql;

  -- just in case this is a re-install / upgrade, the global contexts will persist so reset them
  logger.null_global_contexts;

end logger_configure;
/

PROMPT install/post_install_configuration.sql 
-- Post installation configuration tasks
PROMPT Calling logger_configure
begin
  logger_configure;
end;
/


-- Only set level if not in DEBUG mode
PROMPT Setting Logger Level
declare
  l_current_level logger_prefs.pref_value%type;
begin

  select pref_value
  into l_current_level
  from logger_prefs
  where 1=1
    and pref_type = logger.g_pref_type_logger
    and pref_name = 'LEVEL';
    
  update logger_prefs
    set pref_value='FALSE'
  where pref_name='PROTECT_ADMIN_PROCS';
  commit;  

  -- Note: Probably not necessary but pre 1.4.0 code had this in place
  logger.set_level(l_current_level);
  update logger_prefs
    set pref_value='TRUE'
  where pref_name='PROTECT_ADMIN_PROCS';    
  commit;
end;
/

prompt
prompt *************************************************
prompt Now executing LOGGER.STATUS...
prompt

begin
	logger.status;
end;
/

prompt *************************************************
begin
	logger.log_permanent('Logger version '||logger.get_pref('LOGGER_VERSION')||' installed.');
end;
/


alter view logger_logs_terse compile;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('logger', 'RGRZEGORCZYK', 'changelog/1_changelog_structure.xml', SYSTIMESTAMP, 8, '8:b8519492062bdb81434ff09e5c64a3d6', 'sqlFile', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/constraint/EXPENSES_FK1.sql::EXPENSES_FK1::rgrzegorczyk
ALTER TABLE EXPENSES ADD CONSTRAINT EXPENSES_FK1 FOREIGN KEY (EXPENSE_TYPES_ID)
	  REFERENCES EXPENSE_TYPES (ID) ENABLE;

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('EXPENSES_FK1', 'rgrzegorczyk', 'database/constraint/EXPENSES_FK1.sql', SYSTIMESTAMP, 9, '8:184a008a825de2d76d6697279f69f2ee', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/constraint/EXPENSE_TYPES_FK1.sql::EXPENSE_TYPES_FK1::rgrzegorczyk
ALTER TABLE EXPENSE_TYPES ADD CONSTRAINT EXPENSE_TYPES_FK1 FOREIGN KEY (EXPENSE_GROUP_ID)
	  REFERENCES EXPENSE_GROUPS (ID) ON DELETE CASCADE ENABLE;

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('EXPENSE_TYPES_FK1', 'rgrzegorczyk', 'database/constraint/EXPENSE_TYPES_FK1.sql', SYSTIMESTAMP, 10, '8:fb425d69f3df18115f9c08cb4ef929be', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/trigger/expense_groups_biu_trg.sql::expense_groups_biu_trg::RGRZEGORCZYK
create or replace trigger expense_groups_biu_trg
    before insert or update 
    on expense_groups
    for each row
begin
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end expense_groups_biu;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expense_groups_biu_trg', 'RGRZEGORCZYK', 'database/trigger/expense_groups_biu_trg.sql', SYSTIMESTAMP, 11, '8:c01ac52f05d84cbdc8859804c5ca28fc', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/trigger/expense_types_biu_trg.sql::expense_types_biu_trg::RGRZEGORCZYK
create or replace trigger expense_types_biu_trg
    before insert or update 
    on expense_types
    for each row
begin
    if inserting then
        :new.created := sysdate;
        :new.created_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
    end if;
    :new.updated := sysdate;
    :new.updated_by := nvl(sys_context('APEX$SESSION','APP_USER'),user);
end expense_types_biu;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expense_types_biu_trg', 'RGRZEGORCZYK', 'database/trigger/expense_types_biu_trg.sql', SYSTIMESTAMP, 12, '8:33576c1f4c773e3289a25ce2f2a78b72', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/trigger/expenses_biu_trg.sql::expenses_biu_trg::RGRZEGORCZYK
create or replace trigger expenses_biu_trg
   before insert or update on expenses
   for each row
begin
   if inserting then
      :new.created        := sysdate;
      :new.created_by     := nvl(sys_context('APEX$SESSION', 'APP_USER'), user);
   end if;
   :new.updated        := sysdate;
   :new.updated_by     := nvl(sys_context('APEX$SESSION', 'APP_USER'), user);
end expenses_biu;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('expenses_biu_trg', 'RGRZEGORCZYK', 'database/trigger/expenses_biu_trg.sql', SYSTIMESTAMP, 13, '8:2282edd3f8257d3fd3aa6d44aa36a3ea', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/trigger/expenses_id_h_auid_trg.sql::EXPENSES_ID_H_AIUD_TRG::RGRZEGORCZYK
create or replace trigger EXPENSES_ID_H_AIUD_TRG
after insert or update or delete on EXPENSES
for each row
begin
IF INSERTING THEN
  insert into EXPENSES_h(hist_op_type, hist_op_ts, hist_user, ID, EXPENSE_TYPES_ID, EXPENSE_DATE, VALUE, COMMENTS, CREATED, CREATED_BY, UPDATED, UPDATED_BY,  IS_RETURNED, RETURN_WIRE_RECEIVED, RETURN_VALUE)
  values ('I', systimestamp, NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'), user), :new.ID, :new.EXPENSE_TYPES_ID, :new.EXPENSE_DATE, :new.VALUE, :new.COMMENTS, :new.CREATED, :new.CREATED_BY, :new.UPDATED, :new.UPDATED_BY, :new.IS_RETURNED, :new.RETURN_WIRE_RECEIVED, :new.RETURN_VALUE);
ELSIF UPDATING THEN
  insert into EXPENSES_h(hist_op_type, hist_op_ts, ID, EXPENSE_TYPES_ID, EXPENSE_DATE, VALUE, COMMENTS, CREATED, CREATED_BY, UPDATED, UPDATED_BY, hist_user, IS_RETURNED, RETURN_WIRE_RECEIVED, RETURN_VALUE)
  values ('U', systimestamp, :new.ID, :new.EXPENSE_TYPES_ID, :new.EXPENSE_DATE, :new.VALUE, :new.COMMENTS, :new.CREATED, :new.CREATED_BY, :new.UPDATED, :new.UPDATED_BY, NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'), user),  :new.IS_RETURNED, :new.RETURN_WIRE_RECEIVED, :new.RETURN_VALUE);
ELSIF DELETING THEN
  insert into EXPENSES_h(hist_user, hist_op_type, hist_op_ts, ID)
  values (NVL(SYS_CONTEXT('APEX$SESSION','APP_USER'), user), 'D', systimestamp, :old.ID);
end if;
end;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('EXPENSES_ID_H_AIUD_TRG', 'RGRZEGORCZYK', 'database/trigger/expenses_id_h_auid_trg.sql', SYSTIMESTAMP, 14, '8:527aaa2d45a289a9d1d25ddc61b7f784', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/trigger/periods_conf_trg.sql::PERIODS_CONF_TRG::RGRZEGORCZYK
CREATE OR REPLACE EDITIONABLE TRIGGER PERIODS_CONF_TRG 
BEFORE INSERT OR UPDATE ON PERIODS_CONF 
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
BEGIN
  :new.code := upper(:new.code);
END;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('PERIODS_CONF_TRG', 'RGRZEGORCZYK', 'database/trigger/periods_conf_trg.sql', SYSTIMESTAMP, 15, '8:18016a86c97a104ba78cfea749f6c914', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/view/EXPENSES_MONTH_DETAILS_V.sql::EXPENSES_MONTH_DETAILS_V_new_cols::RGRZEGORCZYK
CREATE OR REPLACE VIEW EXPENSES_MONTH_DETAILS_V
AS
SELECT e.id,
       e.value expense_value,
       e.comments expense_comment,
       e.expense_date,
       et.name type_name,
       et.id type_id,
       eg.name group_name,
       eg.id group_id,
       pc_month.code month_code,
       pc_year.code year_code,
       e.IS_RETURNED,
       e.RETURN_WIRE_RECEIVED,
       e.RETURN_value,       
       e.comments,
       e.SHOP_NAME,
       e.order_number,
       e.return_details,
       SUM(NVL(e.value,0)) over (partition by et.id,pc_month.code ) sum_month,
       SUM(NVL(e.value,0)) over (partition by et.id,pc_year.code ) sum_year,
       SUM(NVL(e.value,0)) over (partition by eg.id,expense_date ) sum_day
  FROM expenses e
  JOIN expense_types et ON et.id=e.expense_types_id
  JOIN expense_groups eg ON et.expense_group_id=eg.id
  JOIN periods_conf pc_month ON (e.expense_date between pc_month.date_from and pc_month.date_to AND pc_month.type='MONTH')
  JOIN periods_conf pc_year ON (e.expense_date between pc_year.date_from and pc_year.date_to AND pc_year.type='YEAR');

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('EXPENSES_MONTH_DETAILS_V_new_cols', 'RGRZEGORCZYK', 'database/view/EXPENSES_MONTH_DETAILS_V.sql', SYSTIMESTAMP, 16, '8:7baead444a28e889b803007a0475ec7b', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/view/EXPENSES_MONTH_REPORT_V.sql::EXPENSES_MONTH_REPORT_V::RGRZEGORCZYK
CREATE OR REPLACE VIEW EXPENSES_MONTH_REPORT_V
AS
  SELECT x.*
    FROM (
                    WITH rws AS
                         (
                                  SELECT *
                                    FROM (
                                                  SELECT TO_NUMBER (TO_CHAR (e.expense_date, 'DD')) DAY,
                                                         e.expense_value,
                                                         e.group_name,
                                                         e.type_name,
                                                         e.month_code,
                                                         e.group_id,
                                                         --NVL(e.type_name, 'SUMA') type_name,
                                                         (SUM (expense_value) over (PARTITION BY group_name, type_name, month_code)) SUMA
                                                    FROM EXPENSES_MONTH_DETAILS_V e
                                                   WHERE 1 = 1
                                                GROUP BY
                                                         (e.group_name,
                                                         e.type_name,
                                                         expense_value,
                                                         month_code,
                                                         e.group_id,
                                                         TO_NUMBER (TO_CHAR (e.expense_date, 'DD')))
                                         )
                         )
                  SELECT p.*
                    FROM rws pivot (SUM (expense_value) FOR DAY IN (1,
                                                                    2,
                                                                    3,
                                                                    4,
                                                                    5,
                                                                    6,
                                                                    7,
                                                                    8,
                                                                    9,
                                                                    10,
                                                                    11,
                                                                    12,
                                                                    13,
                                                                    14,
                                                                    15,
                                                                    16,
                                                                    17,
                                                                    18,
                                                                    19,
                                                                    20,
                                                                    21,
                                                                    22,
                                                                    23,
                                                                    24,
                                                                    25,
                                                                    26,
                                                                    27,
                                                                    28,
                                                                    29,
                                                                    30,
                                                                    31)) p
         ) x;

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('EXPENSES_MONTH_REPORT_V', 'RGRZEGORCZYK', 'database/view/EXPENSES_MONTH_REPORT_V.sql', SYSTIMESTAMP, 17, '8:099b765c18bd1dda7f3d1a3dec10e0b1', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/view/EXPENSES_YEAR_REPORT_V.sql::EXPENSES_YEAR_REPORT_V::RGRZEGORCZYK
CREATE OR REPLACE VIEW EXPENSES_YEAR_REPORT_V
AS
  SELECT x.*
    FROM (
                    WITH rws AS
                         (
                                  SELECT *
                                    FROM (
                                                  SELECT TO_NUMBER(TO_CHAR (TO_DATE(e.expense_date), 'MM')) MONTH,
                                                         e.expense_value,
                                                         e.group_name,
                                                         e.type_name,
                                                         e.year_code,
                                                         e.group_id,
                                                         (SUM (expense_value) over (PARTITION BY group_name, type_name, year_code)) SUMA
                                                    FROM EXPENSES_MONTH_DETAILS_V e
                                                   WHERE 1 = 1
                                                GROUP BY
                                                         e.group_name,
                                                         e.type_name,
                                                         expense_value,
                                                         year_code,
                                                         e.group_id,
                                                         TO_NUMBER(TO_CHAR (TO_DATE(e.expense_date), 'MM'))
                                         )
                         )
                  SELECT p.*
                    FROM rws pivot (SUM (expense_value) FOR MONTH IN (01 as STYCZEŃ,
                                                                      02 as LUTY,
                                                                      03 as MARZEC,
                                                                      04 as KWIECEŃ,
                                                                      05 as MAJ,
                                                                      06 as CZERWIEC,
                                                                      07 as LIPIEC,
                                                                      08 as SIERPIEŃ,
                                                                      09 as WRZESIEŃ,
                                                                      10 as PAŹDZIERNIK,
                                                                      11 as LISTOPAD,
                                                                      12 as GRUDZIEŃ
                    )) p
         ) x;

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('EXPENSES_YEAR_REPORT_V', 'RGRZEGORCZYK', 'database/view/EXPENSES_YEAR_REPORT_V.sql', SYSTIMESTAMP, 18, '8:bbd667099dc3a823de99e29e3c05e99f', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/view/EXPENSES_YEAR_V.sql::EXPENSES_YEAR_V::RGRZEGORCZYK
CREATE OR REPLACE VIEW EXPENSES_YEAR_V
AS
SELECT 
       et.name type_name,
       et.id type_id,
       eg.name group_name,
       eg.id group_id,
       pc_month.code month_code,
       pc_year.code year_code,
       SUM(e.value) sum
  FROM expenses e
  JOIN expense_types et ON et.id=e.expense_types_id
  JOIN expense_groups eg ON et.expense_group_id=eg.id
  JOIN periods_conf pc_month ON (e.expense_date between pc_month.date_from and pc_month.date_to AND pc_month.type='MONTH')
  JOIN periods_conf pc_year ON (e.expense_date between pc_year.date_from and pc_year.date_to AND pc_year.type='YEAR')
  GROUP BY        et.name,
       et.id ,
       eg.name ,
       eg.id ,
       pc_month.code ,
       pc_year.code;

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('EXPENSES_YEAR_V', 'RGRZEGORCZYK', 'database/view/EXPENSES_YEAR_V.sql', SYSTIMESTAMP, 19, '8:733e0f7d1cab2867fc78057ffa966634', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/view/PERIODS_V.sql::PERIODS_V::RGRZEGORCZYK
CREATE OR REPLACE FORCE EDITIONABLE VIEW PERIODS_V
  as
  SELECT   MTH.CODE       AS MONTH_PERIOD
         , MTH.DATE_FROM  AS MONTH_PERIOD_FROM
         , MTH.DATE_TO    AS MONTH_PERIOD_TO
         , QT.CODE        AS QUARTER_PERIOD
         , QT.DATE_FROM   AS QUARTER_PERIOD_FROM
         , QT.DATE_TO     AS QUARTER_PERIOD_TO
         , Y.CODE         AS YEAR_PERIOD
         , Y.DATE_FROM    AS YEAR_PERIOD_FROM
         , Y.DATE_TO      AS YEAR_PERIOD_TO 
         , D.CODE         AS DAY_PERIOD
         , D.DATE_FROM    AS DAY_PERIOD_FROM
         , D.DATE_TO      AS DAY_PERIOD_TO                     

      FROM PERIODS_CONF MTH
 LEFT JOIN PERIODS_CONF QT
        ON QT.DATE_FROM <= MTH.DATE_FROM
       AND QT.DATE_TO   >= MTH.DATE_TO
       AND QT.TYPE       = 'QUARTER'
LEFT JOIN PERIODS_CONF Y
       ON mth.date_from >= y.date_from
      AND mth.date_to   <= y.date_to  
      AND y.type='YEAR'     
LEFT JOIN PERIODS_CONF D
       ON d.date_from   >= mth.date_from
      AND d.date_to     <= mth.date_to  
      AND d.type='DAY';

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('PERIODS_V', 'RGRZEGORCZYK', 'database/view/PERIODS_V.sql', SYSTIMESTAMP, 20, '8:27f5264bc666a0919041c2c652a909cf', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset database/type/call_result.sql::CALL_RESULT::rgrzegorczyk
--------------------------------------------------------
--  DDL for Type CALL_RESULT
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE TYPE CALL_RESULT AS OBJECT
(
  STATUS varchar2(30 byte),
  MESSAGE varchar2(4000 byte),
  EXTRA_CODE varchar2(100 byte),
  NEW_OBJECT_ID NUMBER,
  COUNT_OK number,
  COUNT_ERR number,
CONSTRUCTOR FUNCTION CALL_RESULT  RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2) RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2) RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2, pi_count_ok NUMBER, pi_count_err NUMBER) RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2,pi_EXTRA_CODE VARCHAR2) RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2, pi_NEW_OBJECT_ID NUMBER) RETURN SELF AS RESULT,
CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2, pi_EXTRA_CODE VARCHAR2, pi_NEW_OBJECT_ID NUMBER) RETURN SELF AS RESULT,

MEMBER function RESULT_OK(pi_message varchar2) return CALL_RESULT,
MEMBER function RESULT_ERR(pi_message varchar2) return CALL_RESULT,

MEMBER function IS_OK return BOOLEAN,
MEMBER function IS_NOT_OK return BOOLEAN,
MEMBER function IS_ERR return BOOLEAN,
MEMBER function IS_NOT_ERR return BOOLEAN

);
/

CREATE OR REPLACE EDITIONABLE TYPE BODY "CALL_RESULT" as

CONSTRUCTOR FUNCTION CALL_RESULT  RETURN SELF AS RESULT
AS
BEGIN
  SELF.STATUS:=null;
  SELF.MESSAGE:=null;
  SELF.EXTRA_CODE:=null;
  SELF.NEW_OBJECT_ID:=null;  RETURN;
END;

CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2) RETURN SELF AS RESULT
AS
BEGIN
  SELF.STATUS:=pi_status;
  SELF.MESSAGE:=null;
  SELF.EXTRA_CODE:=null;
  SELF.NEW_OBJECT_ID:=null;
  RETURN;
END;

CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2) RETURN SELF AS RESULT
AS
BEGIN
  SELF.STATUS:=pi_status;
  SELF.MESSAGE:=pi_message;
  SELF.EXTRA_CODE:=null;
  SELF.NEW_OBJECT_ID:=null;
  RETURN;
END;

CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2, pi_count_ok NUMBER, pi_count_err NUMBER) RETURN SELF AS RESULT
AS
BEGIN
  SELF.STATUS:=pi_status;
  SELF.MESSAGE:=pi_message;
  SELF.EXTRA_CODE:=null;
  SELF.NEW_OBJECT_ID:=null;
  SELF.COUNT_OK := pi_count_ok;
  SELF.COUNT_ERR := pi_count_err;
  RETURN;
END;


CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2,pi_EXTRA_CODE VARCHAR2) RETURN SELF AS RESULT
AS
BEGIN
  SELF.STATUS:=pi_status;
  SELF.MESSAGE:=pi_message;
  SELF.EXTRA_CODE:=pi_EXTRA_CODE;
  SELF.NEW_OBJECT_ID:=null;
  RETURN;
END;

CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2, pi_NEW_OBJECT_ID NUMBER) RETURN SELF AS RESULT
AS
BEGIN
  SELF.STATUS:=pi_status;
  SELF.MESSAGE:=pi_message;
  SELF.EXTRA_CODE:=null;
  SELF.NEW_OBJECT_ID:=pi_NEW_OBJECT_ID;
  RETURN;
END;

CONSTRUCTOR FUNCTION CALL_RESULT(pi_status VARCHAR2, pi_message VARCHAR2, pi_EXTRA_CODE VARCHAR2, pi_NEW_OBJECT_ID NUMBER) RETURN SELF AS RESULT
AS
BEGIN
  SELF.STATUS:=pi_status;
  SELF.MESSAGE:=pi_message;
  SELF.EXTRA_CODE:=pi_EXTRA_CODE;
  SELF.NEW_OBJECT_ID:=pi_NEW_OBJECT_ID;
  RETURN;
END;


MEMBER function RESULT_OK(pi_message varchar2) return CALL_RESULT AS
BEGIN
  RETURN CALL_RESULT(CONST_PKG.C_RESULT_OK,pi_message);
END;

MEMBER function RESULT_ERR(pi_message varchar2) return CALL_RESULT AS
BEGIN
  RETURN CALL_RESULT(CONST_PKG.C_RESULT_ERR,pi_message);
END;

MEMBER function IS_OK return BOOLEAN
AS
BEGIN
  IF self.STATUS = CONST_PKG.C_RESULT_OK THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;

MEMBER function IS_NOT_OK return BOOLEAN
AS
BEGIN
  IF self.STATUS = CONST_PKG.C_RESULT_OK THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;
END;

MEMBER function IS_ERR return BOOLEAN
AS
BEGIN
  IF self.STATUS = CONST_PKG.C_RESULT_ERR THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
END;

MEMBER function IS_NOT_ERR return BOOLEAN
AS
BEGIN
  IF self.STATUS = CONST_PKG.C_RESULT_ERR THEN
    RETURN FALSE;
  ELSE
    RETURN TRUE;
  END IF;
END;
END;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('CALL_RESULT', 'rgrzegorczyk', 'database/type/call_result.sql', SYSTIMESTAMP, 21, '8:972db254328ef339d8296a0b129e7a8a', 'sql', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/4_changelog_replaceable.xml::CONST_PKG::rgrzegorczyk
-- Const_pkg must go first!
CREATE OR REPLACE EDITIONABLE PACKAGE "CONST_PKG" 
AS
/**
* Projekt:          SC<br/>
* Opis:             Pakiet zawierajacy defnicje stalych<br/>
* DB impact:        NO<br/>
* Commit inside:    NO<br/>
* Rollback inside:  NO<br/>
* @headcom
*/

  SUBTYPE t_code IS VARCHAR2(50);    

  c_sc_apex_aplication_id            NUMBER := 200; -- zakladam ze na takim ID jest nasza aplikacja (w razie zmiany trzeba to zmienic bo komunikaty przestana dzialac )

  -- kody bledow
  c_result_err                       VARCHAR2(20) := 'ERR';
  c_result_ok                        VARCHAR2(20) := 'OK';
  c_result_war                       VARCHAR2(20) := 'WAR';

  -- kody funkcji GUI
  c_command_insert                  VARCHAR2(30) := 'INSERT';
  c_command_update                  VARCHAR2(30) := 'UPDATE';
  c_command_delete                  VARCHAR2(30) := 'DELETE';
  c_command_copy                    VARCHAR2(30) := 'COPY';
  
  --kody funkcji na GUI dla Interactive Grid (APEX$ROW_STATUS)
  c_command_ig_insert               VARCHAR2(50) := 'C';
  c_command_ig_update               VARCHAR2(50) := 'U';
  c_command_ig_delete               VARCHAR2(50) := 'D';
  
 
  -- komunikaty bedów
  c_when_others_message             VARCHAR2(100) := 'Nieoczekiwany problem';
  c_unsupported_message VARCHAR2(100) := 'Procedura/Funkcja jest w tym momencie zablokowana.' ;


  FUNCTION f_get_buffer_schema
    RETURN VARCHAR2;

  FUNCTION f_get_core_schema
    RETURN VARCHAR2;

  FUNCTION f_REPL_table_prefix
    RETURN VARCHAR2;

  FUNCTION f_EXT_table_prefix
    RETURN VARCHAR2;

END CONST_PKG;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('CONST_PKG', 'rgrzegorczyk', 'changelog/4_changelog_replaceable.xml', SYSTIMESTAMP, 22, '8:65229a84c9ea4bb0fd73e4f62b83f139', 'sqlFile', 'Const_pkg must go first!', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/4_changelog_replaceable.xml::APEX_UTIL_PKG::rgrzegorczyk
CREATE OR REPLACE EDITIONABLE PACKAGE APEX_UTIL_PKG 
as

 

  procedure p_show_message(
    pi_message IN CALL_RESULT
  );

  /** Procedura która wyswietla komunikat jako success message na gui
   * @param pi_message zmienna typu VARCHAR2 zawierajaca komunikat success message wyswietlanej na GUI
  */

  procedure p_show_success_message(
    pi_message IN VARCHAR2
  );

  /** Procedura która wyswietla komunikat bledu na gui
   * @param pi_message zmienna typu VARCHAR2 zawierajaca komunikat bledu wyswietlanej na GUI
  */

  procedure p_show_error_message(
    pi_message IN VARCHAR2
  );

  /** Procedura która wyswietla komunikat bledu na gui jednoczesnie globalnie na stronie i przy itemie ktorego dotyczy
   * @param pi_message zmienna typu VARCHAR2 zawierajaca komunikat bledu wyswietlanej na GUI
   * @param pi_item_name zmienna typu VARCHAR2 do ktorego komunikat bledu zostanie przypisany
  */

  procedure p_show_error_message(
    pi_message IN VARCHAR2,
    pi_item_name IN VARCHAR2
  );



  function f_lang (
    pi_message in varchar2,
    pi_p0      in varchar2 default null,
    pi_p1      in varchar2 default null,
    pi_p2      in varchar2 default null,
    pi_p3      in varchar2 default null,
    pi_p4      in varchar2 default null,
    pi_p5      in varchar2 default null,
    pi_p6      in varchar2 default null,
    pi_p7      in varchar2 default null,
    pi_p8      in varchar2 default null,
    pi_p9      in varchar2 default null,
    pi_p_lang  in varchar2 default null
  ) return varchar2;




end APEX_UTIL_PKG;
/

CREATE OR REPLACE EDITIONABLE PACKAGE BODY APEX_UTIL_PKG AS

--==== Logger scope ====--
  gc_scope_prefix constant VARCHAR2(31) := lower($$PLSQL_UNIT) || '.';

--==== TYPES ====----
  c_APP_CN_ITEM_NAME CONSTANT VARCHAR2(100) := 'APP_CN';

--==== GLOBALS ====----
  g_coll_name   APEX_COLLECTIONS.COLLECTION_NAME%TYPE := c_APP_CN_ITEM_NAME;  

--==== Functions and procedures  ====--

-- show success message on GUI
  procedure p_show_success_message(
    pi_message IN VARCHAR2
  ) AS
      v_scope logger_logs.scope%type := gc_scope_prefix || 'p_show_success_message' ;
      v_params logger.tab_param;
  BEGIN
  logger.append_param(v_params, 'pi_message', pi_message);
  logger.log('START', v_scope, null, v_params);

  APEX_UTIL.set_session_state(p_name => 'APP_SUCCESS_MESSAGE', p_value => pi_message);

  apex_application.g_print_success_message := pi_message;

  logger.log('END', v_scope);
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END p_show_success_message;

--------------------------------------------------------------------------------
-- translates codes using apex_lang
  function f_lang(
    pi_message in varchar2,
    pi_p0      in varchar2 default null,
    pi_p1      in varchar2 default null,
    pi_p2      in varchar2 default null,
    pi_p3      in varchar2 default null,
    pi_p4      in varchar2 default null,
    pi_p5      in varchar2 default null,
    pi_p6      in varchar2 default null,
    pi_p7      in varchar2 default null,
    pi_p8      in varchar2 default null,
    pi_p9      in varchar2 default null,
    pi_p_lang  in varchar2 default null
  ) return varchar2
  IS

    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_lang' ;
    v_params logger.tab_param;

    v_return APEX_APPLICATION_TRANSLATIONS.message_text%TYPE;

  BEGIN

    logger.append_param(v_params, 'pi_message', pi_message);
    logger.log('START', v_scope, null, v_params);

    IF SYS_CONTEXT('APEX$SESSION','APP_SESSION') is not null then
      v_return := apex_lang.message(
                    p_name => pi_message,
                    p0 => pi_p0,
                    p1 => pi_p1,
                    p2 => pi_p2,
                    p3 => pi_p3,
                    p4 => pi_p4,
                    p5 => pi_p5,
                    p6 => pi_p6,
                    p7 => pi_p7,
                    p8 => pi_p8,
                    p9 => pi_p9,
                    p_lang => pi_p_lang
                  );

      IF v_return = pi_message then
        logger.log_error('No translation found for code'||pi_message||'in apex_lang');
      END IF;

    ELSE
      Select
        message_text 
      into 
        v_return
      from APEX_APPLICATION_TRANSLATIONS
      where 1 = 1
        and lower(language_code) = nvl(pi_p_lang,'pl') -- default language code PL
        and application_id = const_pkg.c_sc_apex_aplication_id
        and TRANSLATABLE_MESSAGE = pi_message;
    END IF;

    logger.log('END', v_scope);
    return v_return;

  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    logger.log_error('No translation found for code'||pi_message||'in apex_lang');
    --raise;
    return pi_message;
  END f_lang;

--------------------------------------------------------------------------------
-- error message on GUI
  procedure p_show_error_message(
    pi_message IN VARCHAR2
  ) AS

    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_show_error_message' ;
    v_params logger.tab_param;
  BEGIN
  logger.append_param(v_params, 'pi_message', pi_message);
  logger.log('START', v_scope, null, v_params);

  APEX_ERROR.ADD_ERROR (
        p_message  => pi_message,
        p_display_location => apex_error.c_inline_in_notification 
      );

  logger.log('END', v_scope);
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END p_show_error_message;

--------------------------------------------------------------------------------

-- error message with field and notification
  procedure p_show_error_message(
    pi_message IN VARCHAR2,
    pi_item_name IN VARCHAR2
  ) AS
      v_scope logger_logs.scope%type := gc_scope_prefix || 'p_show_error_message' ;
      v_params logger.tab_param;
  BEGIN

  logger.append_param(v_params, 'pi_message', pi_message);
  logger.append_param(v_params, 'pi_item_name', pi_item_name);
  logger.log('START', v_scope, null, v_params);

  APEX_ERROR.ADD_ERROR (
        p_message  => pi_message,
        p_page_item_name => pi_item_name,
        p_display_location => apex_error.c_inline_with_field_and_notif
      );

  logger.log('END', v_scope);

  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END p_show_error_message;

--------------------------------------------------------------------------------

-- error message depending on CALL_RESULT value
  procedure p_show_message(
    pi_message IN CALL_RESULT
  ) AS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_show_message' ;
    v_params logger.tab_param;

  BEGIN

  logger.append_param(v_params, 'pi_message', pi_message.message);
  logger.log('START', v_scope, null, v_params);

  CASE pi_message.status
    WHEN const_pkg.c_result_ok then p_show_success_message(pi_message => pi_message.message);
    WHEN const_pkg.c_result_err then p_show_error_message(pi_message => pi_message.message);
    ELSE logger.log_error('Unsupported message');
  END CASE;

  logger.log('END', v_scope);
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END p_show_message;


END APEX_UTIL_PKG;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('APEX_UTIL_PKG', 'rgrzegorczyk', 'changelog/4_changelog_replaceable.xml', SYSTIMESTAMP, 23, '8:9858ba9ac947784e689efe81a3789d75', 'sqlFile; sqlFile', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/4_changelog_replaceable.xml::DB_UTIL_PKG::rgrzegorczyk
--liquibase formatted sql
--changeset RGRZEGORCZYK:DB_UTIL_PKG_spec runOnChange:true stripComments:false  stripComments:false context:release_1.0 labels:release_1.0
--rollback SELECT 1 FROM DUAL;
--------------------------------------------------------
--  DDL for Package DB_UTIL_PKG
--------------------------------------------------------

  CREATE OR REPLACE EDITIONABLE PACKAGE "DB_UTIL_PKG" AS 

--=============================SYBTYPES=======================================--
  SUBTYPE param_index_type IS VARCHAR2(32);
  SUBTYPE param_value_type IS VARCHAR2(4000);

--=============================TYPES==========================================--
/** Typ - tablica varchar2
*/
  TYPE t_varchar2 IS TABLE OF param_value_type;

  TYPE t_outer_args IS TABLE OF t_varchar2
    INDEX BY param_index_type;

--===========================FUNCTIONS========================================--

/** Funkcja rozdzielajaca ciag znakow po separatorach
* @param pi_string ciag znakow z ktorego chcemy utworzyc tablice pipelined
* @param pi_separator separator po ktorym rozpoznajemy kolejne elementy tablicy
*/

  FUNCTION in_list (
                    pi_string     IN  VARCHAR2,
                    pi_separator  IN  VARCHAR2
  ) RETURN t_varchar2 PIPELINED DETERMINISTIC;



END DB_UTIL_PKG;
/

CREATE OR REPLACE EDITIONABLE PACKAGE BODY "DB_UTIL_PKG" AS

--==== Scope loggera ====--
  gc_scope_prefix constant VARCHAR2(1000) := lower($$PLSQL_UNIT) || '.';
--==== Typy ====--

--==== Zmienne Globalne ====--
  gv_TAPI           VARCHAR2(32767);
  gv_table_name     VARCHAR2(200);
  gv_table_schema   VARCHAR2(200);


--==== Funkcje glowne pakietu DB_UTIL_PKG  ====--
-- Funkcja zwracajaca po separatorze tabelice PIPELINED deterministyczna
  FUNCTION in_list (
                    pi_string     IN VARCHAR2,
                    pi_separator  IN VARCHAR2
  ) RETURN t_varchar2 PIPELINED DETERMINISTIC
  AS
    l_text  VARCHAR2(32767) := pi_string || pi_separator;
    l_idx   NUMBER;
  BEGIN
    LOOP
      l_idx := INSTR(l_text, pi_separator);
      EXIT WHEN NVL(l_idx, 0) = 0;
      PIPE ROW (TRIM(SUBSTR(l_text, 1, l_idx - 1)));
      l_text := SUBSTR(l_text, l_idx + 1);
    END LOOP;

    RETURN;
  END in_list;

END DB_UTIL_PKG;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('DB_UTIL_PKG', 'rgrzegorczyk', 'changelog/4_changelog_replaceable.xml', SYSTIMESTAMP, 24, '8:e489ebf74c78eae36f0b750941d8319a', 'sqlFile; sqlFile', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/4_changelog_replaceable.xml::EXPENSES_PKG::rgrzegorczyk
CREATE OR REPLACE EDITIONABLE PACKAGE "EXPENSES_PKG" 
as



  /** Procedura do obsługi tabeli EXPENSES z APEX
   * @param pi_command Komenda definiująca akcje (np.INSERT, UPDATE, DELETE) - słownik dostepnych komend zapisany w CONST_PKG
   * @param pi_app_page ID strony APEX z ktorej zostala funkcja uruchomiona
  */

  procedure p_EXPENSES(
    pi_command IN CONST_PKG.t_code,
    pi_app_page IN NUMBER default v('APP_PAGE_ID')
  );

  /** Funkcja do obsługi tabeli EXPENSES
  * @param pi_command Komenda definiująca akcje (np.INSERT, UPDATE, DELETE) - słownik dostepnych komend zapisany w CONST_PKG
  * @param pi_row Wiersz typu EXPENSES 
  */

  function f_EXPENSES(
    pi_command IN CONST_PKG.t_code,
    pi_row in EXPENSES%ROWTYPE
  ) return CALL_RESULT;

  /** Procedura do pobierania rekordu z tabeli EXPENSES i przypisywania wartosci w APEX na stronie
  * @param pi_app_page ID strony APEX z ktorej zostala funkcja uruchomiona
  */
  procedure p_get_EXPENSES(
    pi_app_page IN NUMBER default v('APP_PAGE_ID')
  );

  /** Funkcja do pobierania rekordu z tabeli EXPENSES
  * @param pi_ID klucz glowny tabeli 
  * @return Zwraca wiersz typu EXPENSES
  */
  function f_get_EXPENSES(
    pi_ID IN EXPENSES.ID%TYPE
  ) return EXPENSES%ROWTYPE;

end EXPENSES_PKG;
/

CREATE OR REPLACE EDITIONABLE PACKAGE BODY "EXPENSES_PKG" AS


--==== Scope loggera ====--
  gc_scope_prefix constant VARCHAR2(1000) := lower($$PLSQL_UNIT) || '.';

--==== Typy ====--


--==== Funkcje i Procedury pomocnicze ====--
  procedure p_set_apex_items(
    pi_app_page IN NUMBER,
    pi_row   IN EXPENSES%ROWTYPE
  )
  as
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_set_apex_items';
    v_params logger.tab_param;

  begin
    logger.append_param(v_params, 'pi_app_page', pi_app_page);
    logger.log('START', v_scope, null, v_params);


    logger.log('EXPENSE_TYPES_ID ' || pi_row.EXPENSE_TYPES_ID, v_scope);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'ID', p_value => pi_row.ID);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'EXPENSE_TYPES_ID', p_value => pi_row.EXPENSE_TYPES_ID);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'EXPENSE_DATE', p_value => pi_row.EXPENSE_DATE);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'VALUE', p_value => pi_row.VALUE);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'COMMENTS', p_value => pi_row.COMMENTS);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'CREATED', p_value => pi_row.CREATED);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'CREATED_BY', p_value => pi_row.CREATED_BY);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'UPDATED', p_value => pi_row.UPDATED);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'UPDATED_BY', p_value => pi_row.UPDATED_BY);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'IS_RETURNED', p_value => pi_row.IS_RETURNED);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'RETURN_WIRE_RECEIVED', p_value => pi_row.RETURN_WIRE_RECEIVED);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'RETURN_VALUE', p_value => pi_row.RETURN_VALUE); 
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'SHOP_NAME', p_value => pi_row.SHOP_NAME); 
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'ORDER_NUMBER', p_value => pi_row.ORDER_NUMBER); 
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'RETURN_DETAILS', p_value => pi_row.RETURN_DETAILS); 

    logger.log('END', v_scope);
  exception
    when others then
      logger.log_error('Nieznany błąd: '||SQLERRM, v_scope, null, v_params);
      raise;
  end p_set_apex_items;

-- procedura pobierająca stan sesji APEX i zwracająca rowtype
  procedure p_get_apex_items (
    pi_app_page IN NUMBER,
    pio_row  IN OUT EXPENSES%ROWTYPE
  )
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_get_apex_items';
    v_params logger.tab_param;
  begin
    logger.append_param(v_params, 'APP_PAGE', pi_app_page);
    logger.log('START', v_scope, null, v_params);

    pio_row.ID   := v('P'||pi_app_page||'_'||'ID');
    pio_row.EXPENSE_TYPES_ID   := v('P'||pi_app_page||'_'||'EXPENSE_TYPES_ID');
    pio_row.EXPENSE_DATE   := v('P'||pi_app_page||'_'||'EXPENSE_DATE');
    pio_row.VALUE   := v('P'||pi_app_page||'_'||'VALUE');
    pio_row.COMMENTS   := v('P'||pi_app_page||'_'||'COMMENTS');
    pio_row.CREATED   := v('P'||pi_app_page||'_'||'CREATED');
    pio_row.CREATED_BY   := v('P'||pi_app_page||'_'||'CREATED_BY');
    pio_row.UPDATED   := v('P'||pi_app_page||'_'||'UPDATED');
    pio_row.UPDATED_BY   := v('P'||pi_app_page||'_'||'UPDATED_BY');
    pio_row.IS_RETURNED   := v('P'||pi_app_page||'_'||'IS_RETURNED');
    pio_row.RETURN_WIRE_RECEIVED   := v('P'||pi_app_page||'_'||'RETURN_WIRE_RECEIVED');                
    pio_row.RETURN_VALUE   := v('P'||pi_app_page||'_'||'RETURN_VALUE');   
    pio_row.SHOP_NAME   := v('P'||pi_app_page||'_'||'SHOP_NAME');    
    pio_row.ORDER_NUMBER   := v('P'||pi_app_page||'_'||'ORDER_NUMBER');    
    pio_row.RETURN_DETAILS   := v('P'||pi_app_page||'_'||'RETURN_DETAILS');    



    logger.log('END', v_scope);
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END;

-- Funkcja pomocnicza sprawdzajaca czy parametry wejsciowe nie sa nullem --
  function f_check_parameters (
    pi_function_name IN CONST_PKG.t_code,
    pi_command       IN CONST_PKG.t_code
  ) return boolean
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_check_parameters';
  BEGIN
    IF pi_command is null THEN
      logger.log('Wywolanie ''||pi_function_name||'' - Komenda nie moze byc NULLem!', v_scope);
      return false;
    END IF;

    IF upper(pi_command) not in (CONST_PKG.C_COMMAND_INSERT, CONST_PKG.C_COMMAND_UPDATE, CONST_PKG.C_COMMAND_COPY, CONST_PKG.C_COMMAND_DELETE) THEN
      logger.log('Wykryto nieprawidlowa komende ''||pi_command||'' przy wywolaniu funkcji '||pi_function_name, v_scope);
      return false;
    END IF;

    logger.log('Parametry wywolania funkcji '||pi_function_name||' prawidlowe.', v_scope);
    return true;
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error();
    raise;
    return false;
  END;


  -- funkcje przygotowujace dane
  function f_prepareString(
    pi_string IN varchar2
  ) return varchar2
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_prepareString';
  BEGIN
    logger.log('Przygotowuje stringa '||pi_string, v_scope);
    return trim(upper(pi_string));
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END;

  function f_prepareNumber(
    pi_number IN number
  ) return number
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_prepareNumber';
  BEGIN
    logger.log('Przygotowuje liczbe: '||pi_number, v_scope);
    return pi_number;
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END;

  function f_prepareDate(
    pi_date IN varchar2
  ) return varchar2
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_prepareDate';
  BEGIN
    logger.log('Przygotowuje date: '||pi_date, v_scope);
    return trunc(to_date(pi_date));
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END;

--==== Koniec funkcji pomocniczych ====--


--==== Funkcje wywolujace modyfikacje konkretnych danych ====--


  -- Procedura przygotowujaca dane
  procedure p_EXPENSES_prepare(
    pio_row IN OUT EXPENSES%ROWTYPE
  )
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_EXPENSES_prepare' ;
    v_params logger.tab_param;
  BEGIN
    logger.log('START', v_scope, null, v_params);

    -- tutaj modyfikujemy rekord (status, wartosci itp.) gdyby cos trzeba bylo zmienic przed wlasciwa akcja

    logger.log('STOP', v_scope);
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END p_EXPENSES_prepare;


  -- funkcja sprawdzajaca czy istnieje juz taki wpis
  function f_EXPENSES_exists(
    pi_row IN EXPENSES%ROWTYPE
  ) return BOOLEAN
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_EXPENSES_exists' ;
    v_params logger.tab_param;

    v_count NUMBER := 0;
  BEGIN

    logger.append_param(v_params, 'EXPENSES_ID', pi_row.ID);
    logger.log('START', v_scope, null, v_params);

    -- sprawdzam czy istnieje taki wpis w wynikach
    SELECT 
      count(1)
    INTO
      v_count
    FROM 
      EXPENSES 
    WHERE 1 = 1
      and ID = pi_row.ID
      ;

    logger.log('STOP. Istnieje takich wpisów: '||v_count, v_scope);

    -- jezeli tak, to zwracam true
    IF v_count is not null AND v_count > 0 THEN
      return false;
    END IF;

    return true;
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END f_EXPENSES_exists;


  -- funkcja dodajaca nowe dane
  function f_EXPENSES_insert(
    pi_row IN EXPENSES%ROWTYPE
  ) return CALL_RESULT
  IS
    v_row EXPENSES%ROWTYPE := pi_row;
    v_return_id NUMBER;

    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_EXPENSES_insert' ;
    v_params logger.tab_param;
  BEGIN
    p_EXPENSES_prepare(v_row);
    logger.append_param(v_params, 'EXPENSES_ID', v_row.ID);

    logger.log('START', v_scope, null, v_params);
    logger.log('expense_types.id => '|| v_row.expense_types_id, v_scope);    

    /*
    Warunki biznesowe. Warunki techniczne i logiczne powinny byc obsluzone na tabelach.
    */
    IF not f_EXPENSES_exists(pi_row => v_row) THEN
      return HANDLE_PKG.ERR_MESSAGE( apex_util_pkg.f_lang('TAPI_EXISTS_ERROR') , v_scope);
    END IF;

    logger.log('Rozpoczynam dodawanie rekordu.', v_scope);

    -- robimy inserta
    INSERT
    INTO EXPENSES
      VALUES v_row
    ; 

    logger.log('STOP. Zakonczono sukcesem.', v_scope);

    return HANDLE_PKG.OK_MESSAGE( apex_util_pkg.f_lang('EXPENSES_TAPI_SUCCESS_INSERT') , v_return_id, v_scope);
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope);
    raise;
  END f_EXPENSES_insert;
  ----


  -- funkcja aktualizujaca dane

  function f_EXPENSES_update(
    pi_row IN EXPENSES%ROWTYPE
  ) return CALL_RESULT
  IS
    v_row EXPENSES%ROWTYPE := pi_row;

    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_EXPENSES_update' ;
    v_params logger.tab_param;
    v_old_row EXPENSES%ROWTYPE;
  BEGIN

    p_EXPENSES_prepare(v_row);

   --get row before UPDATE
    v_old_row := f_get_EXPENSES(pi_row.ID);
    logger.append_param(v_params, 'EXPENSES_ID', v_row.ID);

    logger.log('START', v_scope, null, v_params);

    IF v_row.ID is null THEN
      return HANDLE_PKG.ERR_MESSAGE( apex_util_pkg.f_lang('TAPI_PK_ERROR_UPDATE') , v_scope);
    END IF;

    logger.log('Rozpoczynam aktualizacje rekordu', v_scope);

    --set return value only it wasn't marked as returned before
    IF v_row.is_returned = 'Y' and v_old_row.is_returned ='N' THEN 
      v_row.value := NVL(v_row.value,0) - NVL(v_row.return_value,0);
    END IF; 
     
    IF v_row.is_returned = 'N' THEN 
      v_row.return_value := NULL;
    END IF;         

    UPDATE EXPENSES
    SET ROW = v_row
    WHERE 1 = 1
      and ID = v_row.ID
    ;

    logger.log('STOP. Zakonczono sukcesem.', v_scope);

    return HANDLE_PKG.OK_MESSAGE( apex_util_pkg.f_lang('EXPENSES_TAPI_SUCCESS_UPDATE') , null, v_scope);

  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;
  END f_EXPENSES_update;

--------------------------------------------------------------------------------

   -- funkcja usuwająca dane
  function f_EXPENSES_delete(
    pi_row IN EXPENSES%ROWTYPE
  ) return CALL_RESULT
  IS
    v_row          EXPENSES%ROWTYPE := pi_row;

    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_EXPENSES_delete' ;
    v_params logger.tab_param;
  BEGIN
    logger.append_param(v_params, 'EXPENSES_ID', v_row.ID);

    logger.log('START', v_scope, null, v_params);

    IF v_row.ID is null THEN
      return HANDLE_PKG.ERR_MESSAGE( apex_util_pkg.f_lang('TAPI_PK_ERROR_DELETE') , v_scope);
    END IF;

    logger.log('Rozpoczynam usuwanie rekordu', v_scope);

    DELETE 
      EXPENSES
    WHERE 1 = 1
      and ID = v_row.ID
      ;

    logger.log('STOP. Zakonczono sukcesem.', v_scope);

    return HANDLE_PKG.OK_MESSAGE( apex_util_pkg.f_lang('EXPENSES_TAPI_SUCCESS_DELETE') , null, v_scope);

  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;
  END f_EXPENSES_delete;

--------------------------------------------------------------------------------

   -- funkcja usuwajaca dane
  function f_EXPENSES_copy(
    pi_row IN EXPENSES%ROWTYPE
  ) return CALL_RESULT
  IS
    v_row          EXPENSES%ROWTYPE := pi_row;
    v_return_message CALL_RESULT;

    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_EXPENSES_copy' ;
    v_params logger.tab_param;
  BEGIN
    logger.append_param(v_params, 'EXPENSES_ID', v_row.ID);

    logger.log('START', v_scope, null, v_params);

    IF v_row.ID is null THEN
      return HANDLE_PKG.ERR_MESSAGE( apex_util_pkg.f_lang('TAPI_PK_ERROR_COPY') , v_scope);
    END IF;


    logger.log('Rozpoczynam kopiowanie rekordu', v_scope);

    v_return_message := f_EXPENSES_insert(v_row);

    logger.log('STOP. Zakonczono sukcesem.', v_scope);

    return v_return_message;

  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;  
  END f_EXPENSES_copy;

--------------------------------------------------------------------------------

  procedure p_EXPENSES(
    pi_command IN CONST_PKG.t_code,
    pi_app_page IN NUMBER default v('APP_PAGE_ID')
  )
  IS
    v_command CONST_PKG.t_code := f_prepareString(pi_command);
    v_return_message CALL_RESULT;
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_EXPENSES';
    v_params logger.tab_param;

    v_row  EXPENSES%ROWTYPE;
  BEGIN    
    logger.append_param(v_params, 'COMMAND', pi_command);
    logger.append_param(v_params, 'APP_PAGE', pi_app_page);
    logger.log('START', v_scope, null, v_params);
    p_get_apex_items(pi_app_page, v_row);
    v_return_message := f_EXPENSES(
                                    pi_command => pi_command,
                                    pi_row => v_row
                                    );


    APEX_UTIL_PKG.p_show_message ( pi_message  => v_return_message );

    logger.log('STOP', v_scope);

  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;
  END p_EXPENSES;

--------------------------------------------------------------------------------

  function f_EXPENSES(
    pi_command IN CONST_PKG.t_code,
    pi_row IN EXPENSES%ROWTYPE
  ) return CALL_RESULT 
  IS
    v_command CONST_PKG.t_code := f_prepareString(pi_command);
    v_return_message CALL_RESULT;
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_EXPENSES';
    v_params logger.tab_param;

  BEGIN    
    logger.append_param(v_params, 'COMMAND', pi_command);
    logger.append_param(v_params, 'EXPENSES_ID', pi_row.ID);

    logger.log('START', v_scope, null, v_params);


    IF f_check_parameters('f_EXPENSES', v_command) THEN
      CASE v_command
        WHEN CONST_PKG.C_COMMAND_INSERT THEN v_return_message := f_EXPENSES_insert(pi_row);
        WHEN CONST_PKG.C_COMMAND_UPDATE THEN v_return_message := f_EXPENSES_update(pi_row);
        WHEN CONST_PKG.C_COMMAND_DELETE THEN v_return_message := f_EXPENSES_delete(pi_row);
        WHEN CONST_PKG.C_COMMAND_COPY THEN v_return_message := f_EXPENSES_copy(pi_row);
      END CASE;
    else
      v_return_message := HANDLE_PKG.err_message( apex_util_pkg.f_lang('TAPI_WRONG_COMMAND_ERROR') , v_scope);
    end if;

    logger.log('STOP', v_scope);

    return v_return_message;
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;    
  END f_EXPENSES;

--------------------------------------------------------------------------------
  procedure p_get_EXPENSES(
      pi_app_page IN NUMBER default v('APP_PAGE_ID')
    )
  as
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_get_EXPENSES';
    v_params logger.tab_param;

    v_row  EXPENSES%ROWTYPE;
  begin
    logger.append_param(v_params, 'pi_app_page', pi_app_page);
    logger.log('START', v_scope, null, v_params);

    p_get_apex_items (
      pi_app_page => pi_app_page,
      pio_row  => v_row
    );

    v_row := f_get_EXPENSES(
                  pi_ID => v_row.ID
                );

    p_set_apex_items(
      pi_app_page => pi_app_page,
      pi_row   => v_row
    );

    logger.log('END', v_scope);
  exception
    when others then
      logger.log_error('Nieznany błąd: '||SQLERRM, v_scope, null, v_params);
      raise;
  end p_get_EXPENSES;

--------------------------------------------------------------------------------
  -- pobranie wiersza EXPENSES na podstawie klucza glownego
  function f_get_EXPENSES(
    pi_ID IN EXPENSES.ID%TYPE
  ) return EXPENSES%ROWTYPE
  IS
    v_row          EXPENSES%ROWTYPE;

    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_get_EXPENSES' ;
    v_params logger.tab_param;
  BEGIN
    logger.append_param(v_params, 'ID', pi_ID);

    logger.log('START', v_scope, null, v_params);


    logger.log('Rozpoczynam pobieranie wiersza', v_scope);

    SELECT
      *
    INTO
      v_row
    FROM
      EXPENSES
    WHERE 1 = 1
      and ID = pi_ID
      ;
    logger.log('STOP. Zakonczono sukcesem.', v_scope);

    return v_row;

  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;
  END f_get_EXPENSES;

END EXPENSES_PKG;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('EXPENSES_PKG', 'rgrzegorczyk', 'changelog/4_changelog_replaceable.xml', SYSTIMESTAMP, 25, '8:4b3d305a358d5b49d6bbed9c6843f7b5', 'sqlFile; sqlFile', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/4_changelog_replaceable.xml::HANDLE_PKG::rgrzegorczyk
CREATE OR REPLACE EDITIONABLE PACKAGE "HANDLE_PKG" AS 

  FUNCTION OK_MESSAGE return CALL_RESULT;
  FUNCTION OK_MESSAGE (p_message in varchar2) return CALL_RESULT;


  FUNCTION OK_MESSAGE (p_message in varchar2, p_return_id in number) return CALL_RESULT;

  FUNCTION ERR_MESSAGE (p_message in varchar2) return CALL_RESULT;


  FUNCTION WAR_MESSAGE (p_message in varchar2) return CALL_RESULT;

  FUNCTION OK_MESSAGE (p_message in varchar2, p_scope in logger_logs.scope%type) return CALL_RESULT;
  FUNCTION OK_MESSAGE (p_message in varchar2, p_return_id in number, p_scope in logger_logs.scope%type) return CALL_RESULT;
  FUNCTION ERR_MESSAGE (p_message in varchar2, p_scope in logger_logs.scope%type) return CALL_RESULT;
  FUNCTION WAR_MESSAGE (p_message in varchar2, p_scope in logger_logs.scope%type) return CALL_RESULT;

  -- na potrzeby business logow dodalem oblusge ok i err countow.
  FUNCTION OK_MESSAGE (p_message in varchar2, pi_count_ok NUMBER, pi_count_err NUMBER) return CALL_RESULT;
  FUNCTION ERR_MESSAGE (p_message in varchar2, pi_count_ok NUMBER, pi_count_err NUMBER) return CALL_RESULT;
  FUNCTION WAR_MESSAGE (p_message in varchar2, pi_count_ok NUMBER, pi_count_err NUMBER) return CALL_RESULT;

END HANDLE_PKG;
/

CREATE OR REPLACE EDITIONABLE PACKAGE BODY HANDLE_PKG AS

 
  FUNCTION OK_MESSAGE  return CALL_RESULT
  is
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_ok);
  begin
    return v_out;
  end OK_MESSAGE;

  FUNCTION OK_MESSAGE (p_message in varchar2) return CALL_RESULT
  is
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_ok, p_message);
  begin
    logger.log_information(v_out.status||' - '||v_out.message);
    return v_out;
  end OK_MESSAGE;

  FUNCTION OK_MESSAGE (p_message in varchar2, pi_count_ok NUMBER, pi_count_err NUMBER) return CALL_RESULT
  is
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_ok, p_message, pi_count_ok, pi_count_err);
  begin
    logger.log_information(v_out.status||' - '||v_out.message);
    return v_out;
  end OK_MESSAGE;

  FUNCTION OK_MESSAGE (p_message in varchar2, p_return_id in number) return CALL_RESULT
  is
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_ok, p_message, p_return_id);
  begin
    logger.log_information(v_out.status||' - '||v_out.message||' - inserted id: '||v_out.NEW_OBJECT_ID);
    return v_out;
  end OK_MESSAGE;

  FUNCTION ERR_MESSAGE (p_message in varchar2) return CALL_RESULT
  IS
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_err, p_message);
  begin
    logger.log_error(v_out.status||' - '||v_out.message);
    return v_out;
  end ERR_MESSAGE;

  FUNCTION ERR_MESSAGE (p_message in varchar2, pi_count_ok NUMBER, pi_count_err NUMBER ) return CALL_RESULT
  IS
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_err, p_message, pi_count_ok, pi_count_err);
  begin
    logger.log_error(v_out.status||' - '||v_out.message);
    return v_out;
  end ERR_MESSAGE;

  FUNCTION WAR_MESSAGE (p_message in varchar2) return CALL_RESULT
  IS
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_war, p_message);
  begin
    logger.log_warning(v_out.status||' - '||v_out.message);
    return v_out;
  end WAR_MESSAGE;

  FUNCTION WAR_MESSAGE (p_message in varchar2, pi_count_ok NUMBER, pi_count_err NUMBER) return CALL_RESULT
  IS
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_war, p_message, pi_count_ok, pi_count_err);
  begin
    logger.log_warning(v_out.status||' - '||v_out.message);
    return v_out;
  end WAR_MESSAGE;

  FUNCTION OK_MESSAGE (p_message in varchar2, p_scope in logger_logs.scope%type) return CALL_RESULT
  is
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_ok, p_message);
  begin
    logger.log_information(v_out.status||' - '||v_out.message, p_scope);
    return v_out;
  end OK_MESSAGE;

  FUNCTION OK_MESSAGE (p_message in varchar2, p_return_id in number, p_scope in logger_logs.scope%type) return CALL_RESULT
  is
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_ok, p_message, p_return_id);
  begin
    logger.log_information(v_out.status||' - '||v_out.message||' - inserted id: '||v_out.NEW_OBJECT_ID, p_scope);
    return v_out;
  end OK_MESSAGE;

  FUNCTION ERR_MESSAGE (p_message in varchar2, p_scope in logger_logs.scope%type) return CALL_RESULT
  IS
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_err, p_message);
  begin
    logger.log_error(v_out.status||' - '||v_out.message, p_scope);
    return v_out;
  end ERR_MESSAGE;

  FUNCTION WAR_MESSAGE (p_message in varchar2, p_scope in logger_logs.scope%type) return CALL_RESULT
  IS
    v_out CALL_RESULT := CALL_RESULT(const_pkg.c_result_war, p_message);
  begin
    logger.log_warning(v_out.status||' - '||v_out.message, p_scope);
    return v_out;
  end WAR_MESSAGE;

END HANDLE_PKG;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('HANDLE_PKG', 'rgrzegorczyk', 'changelog/4_changelog_replaceable.xml', SYSTIMESTAMP, 26, '8:2560fc5042023870d7a40549fc46d105', 'sqlFile; sqlFile', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/4_changelog_replaceable.xml::PERIODS_CONF_PKG::rgrzegorczyk
create or replace package PERIODS_CONF_PKG
as

  procedure p_PERIODS_CONF(
    pi_command IN CONST_PKG.t_code,
    pi_app_page IN NUMBER default v('APP_PAGE_ID')
  );

  
  function f_PERIODS_CONF(
    pi_command IN CONST_PKG.t_code,
    pi_row in PERIODS_CONF%ROWTYPE
  ) return CALL_RESULT;
  

  procedure p_get_PERIODS_CONF(
    pi_app_page IN NUMBER default v('APP_PAGE_ID')
  );
  

  function f_get_PERIODS_CONF(
    pi_CODE IN PERIODS_CONF.CODE%TYPE
  ) return PERIODS_CONF%ROWTYPE;

end PERIODS_CONF_PKG;
/

create or replace PACKAGE BODY PERIODS_CONF_PKG AS


--==== Logger scope ====--
  gc_scope_prefix constant VARCHAR2(1000) := lower($$PLSQL_UNIT) || '.';


  procedure p_set_apex_items(
    pi_app_page IN NUMBER,
    pi_row   IN PERIODS_CONF%ROWTYPE
  )
  as
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_set_apex_items';
    v_params logger.tab_param;
  
  begin
    logger.append_param(v_params, 'pi_app_page', pi_app_page);
    logger.log('START', v_scope, null, v_params);
  
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'CODE', p_value => pi_row.CODE);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'NAME', p_value => pi_row.NAME);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'TYPE', p_value => pi_row.TYPE);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'DATE_FROM', p_value => pi_row.DATE_FROM);
    APEX_UTIL.set_session_state(p_name => 'P'||pi_app_page||'_'||'DATE_TO', p_value => pi_row.DATE_TO);
    
    logger.log('END', v_scope);
  exception
    when others then
      logger.log_error('Unknown error:'||SQLERRM, v_scope, null, v_params);
      raise;
  end p_set_apex_items;

  procedure p_get_apex_items (
    pi_app_page IN NUMBER,
    pio_row  IN OUT PERIODS_CONF%ROWTYPE
  )
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_get_apex_items';
    v_params logger.tab_param;
  begin
    logger.append_param(v_params, 'APP_PAGE', pi_app_page);
    logger.log('START', v_scope, null, v_params);
    
    pio_row.CODE   := v('P'||pi_app_page||'_'||'CODE');
    pio_row.NAME   := v('P'||pi_app_page||'_'||'NAME');
    pio_row.TYPE   := v('P'||pi_app_page||'_'||'TYPE');
    pio_row.DATE_FROM   := v('P'||pi_app_page||'_'||'DATE_FROM');
    pio_row.DATE_TO   := v('P'||pi_app_page||'_'||'DATE_TO');

    
    logger.log('END', v_scope);
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END;

  function f_check_parameters (
    pi_function_name IN CONST_PKG.t_code,
    pi_command       IN CONST_PKG.t_code
  ) return boolean
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_check_parameters';
  BEGIN
    IF pi_command is null THEN
      logger.log('Wywolanie ''||pi_function_name||'' - Komenda nie moze byc NULLem!', v_scope);
      return false;
    END IF;
    
    IF upper(pi_command) not in (CONST_PKG.C_COMMAND_INSERT, CONST_PKG.C_COMMAND_UPDATE, CONST_PKG.C_COMMAND_COPY, CONST_PKG.C_COMMAND_DELETE) THEN
      logger.log('Wykryto nieprawidlowa komende ''||pi_command||'' przy wywolaniu funkcji '||pi_function_name, v_scope);
      return false;
    END IF;
    
    logger.log('Parametry wywolania funkcji '||pi_function_name||' prawidlowe.', v_scope);
    return true;
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error();
    raise;
    return false;
  END;


  function f_prepareString(
    pi_string IN varchar2
  ) return varchar2
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_prepareString';
  BEGIN
    logger.log('Przygotowuje stringa '||pi_string, v_scope);
    return trim(upper(pi_string));
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END;
  
  function f_prepareNumber(
    pi_number IN number
  ) return number
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_prepareNumber';
  BEGIN
    logger.log('Przygotowuje liczbe: '||pi_number, v_scope);
    return pi_number;
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END;
  
  function f_prepareDate(
    pi_date IN varchar2
  ) return varchar2
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_prepareDate';
  BEGIN
    logger.log('Przygotowuje date: '||pi_date, v_scope);
    return trunc(to_date(pi_date));
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END;
  

  procedure p_PERIODS_CONF_prepare(
    pio_row IN OUT PERIODS_CONF%ROWTYPE
  )
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_PERIODS_CONF_prepare' ;
    v_params logger.tab_param;
  BEGIN
    logger.log('START', v_scope, null, v_params);
    
    
    logger.log('STOP', v_scope);
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END p_PERIODS_CONF_prepare;
  
  
  function f_PERIODS_CONF_exists(
    pi_row IN PERIODS_CONF%ROWTYPE
  ) return BOOLEAN
  IS
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_PERIODS_CONF_exists' ;
    v_params logger.tab_param;
    
    v_count NUMBER := 0;
  BEGIN

    logger.append_param(v_params, 'PERIODS_CONF_CODE', pi_row.CODE);
    logger.log('START', v_scope, null, v_params);
    
    SELECT 
      count(1)
    INTO
      v_count
    FROM 
      PERIODS_CONF 
    WHERE 1 = 1
      and CODE = pi_row.CODE
      ;

    logger.log('STOP. Istnieje takich wpisów: '||v_count, v_scope);
    
    IF v_count is not null AND v_count > 0 THEN
      return false;
    END IF;
    
    return true;
  EXCEPTION 
  WHEN OTHERS THEN
    logger.log_error();
    raise;
  END f_PERIODS_CONF_exists;


  function f_PERIODS_CONF_insert(
    pi_row IN PERIODS_CONF%ROWTYPE
  ) return CALL_RESULT
  IS
    v_row PERIODS_CONF%ROWTYPE := pi_row;
    v_return_id NUMBER;
    
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_PERIODS_CONF_insert' ;
    v_params logger.tab_param;
  BEGIN
    p_PERIODS_CONF_prepare(v_row);
    logger.append_param(v_params, 'PERIODS_CONF_CODE', v_row.CODE);
    
    logger.log('START', v_scope, null, v_params);
    
    
    IF not f_PERIODS_CONF_exists(pi_row => v_row) THEN
      return HANDLE_PKG.ERR_MESSAGE( apex_util_pkg.f_lang('TAPI_EXISTS_ERROR') , v_scope);
    END IF;
    
    logger.log('Rozpoczynam dodawanie rekordu.', v_scope);
    
    INSERT
    INTO PERIODS_CONF
      VALUES v_row
    ; 
    
    logger.log('STOP. Success', v_scope);
    
    return HANDLE_PKG.OK_MESSAGE( apex_util_pkg.f_lang('TAPI_SUCCESS_INSERT') , v_return_id, v_scope);
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope);
    raise;
  END f_PERIODS_CONF_insert;
  
  
  function f_PERIODS_CONF_update(
    pi_row IN PERIODS_CONF%ROWTYPE
  ) return CALL_RESULT
  IS
    v_row PERIODS_CONF%ROWTYPE := pi_row;
    
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_PERIODS_CONF_update' ;
    v_params logger.tab_param;
  BEGIN
  
    p_PERIODS_CONF_prepare(v_row);

    logger.append_param(v_params, 'PERIODS_CONF_CODE', v_row.CODE);

    
    logger.log('START', v_scope, null, v_params);
    
    IF v_row.CODE is null THEN
      return HANDLE_PKG.ERR_MESSAGE( apex_util_pkg.f_lang('TAPI_PK_ERROR_UPDATE') , v_scope);
    END IF;
    
    logger.log('Rozpoczynam aktualizacje rekordu', v_scope);
    
    UPDATE PERIODS_CONF
    SET ROW = v_row
    WHERE 1 = 1
      and CODE = v_row.CODE
    ;
    
    logger.log('STOP. Success', v_scope);
    
    return HANDLE_PKG.OK_MESSAGE( apex_util_pkg.f_lang('TAPI_SUCCESS_UPDATE') , null, v_scope);
    
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;
  END f_PERIODS_CONF_update;

--------------------------------------------------------------------------------

   -- funkcja usuwająca dane
  function f_PERIODS_CONF_delete(
    pi_row IN PERIODS_CONF%ROWTYPE
  ) return CALL_RESULT
  IS
    v_row          PERIODS_CONF%ROWTYPE := pi_row;
    
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_PERIODS_CONF_delete' ;
    v_params logger.tab_param;
  BEGIN
    logger.append_param(v_params, 'PERIODS_CONF_CODE', v_row.CODE);
    
    logger.log('START', v_scope, null, v_params);
    
    IF v_row.CODE is null THEN
      return HANDLE_PKG.ERR_MESSAGE( apex_util_pkg.f_lang('TAPI_PK_ERROR_DELETE') , v_scope);
    END IF;
    
    logger.log('Rozpoczynam usuwanie rekordu', v_scope);
    
    DELETE 
      PERIODS_CONF
    WHERE 1 = 1
      and CODE = v_row.CODE
      ;
      
    logger.log('STOP. Success', v_scope);
    
    return HANDLE_PKG.OK_MESSAGE( apex_util_pkg.f_lang('TAPI_SUCCESS_DELETE') , null, v_scope);
    
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;
  END f_PERIODS_CONF_delete;

--------------------------------------------------------------------------------

   -- funkcja usuwajaca dane
  function f_PERIODS_CONF_copy(
    pi_row IN PERIODS_CONF%ROWTYPE
  ) return CALL_RESULT
  IS
    v_row          PERIODS_CONF%ROWTYPE := pi_row;
    v_return_message CALL_RESULT;
    
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_PERIODS_CONF_copy' ;
    v_params logger.tab_param;
  BEGIN
    logger.append_param(v_params, 'PERIODS_CONF_CODE', v_row.CODE);
    
    logger.log('START', v_scope, null, v_params);
    
    IF v_row.CODE is null THEN
      return HANDLE_PKG.ERR_MESSAGE( apex_util_pkg.f_lang('TAPI_PK_ERROR_COPY') , v_scope);
    END IF;
    
    
    logger.log('Rozpoczynam kopiowanie rekordu', v_scope);
    
    v_return_message := f_PERIODS_CONF_insert(v_row);
      
    logger.log('STOP. Success', v_scope);
    
    return v_return_message;
    
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;  
  END f_PERIODS_CONF_copy;
  
--------------------------------------------------------------------------------

  procedure p_PERIODS_CONF(
    pi_command IN CONST_PKG.t_code,
    pi_app_page IN NUMBER default v('APP_PAGE_ID')
  )
  IS
    v_command CONST_PKG.t_code := f_prepareString(pi_command);
    v_return_message CALL_RESULT;
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_PERIODS_CONF';
    v_params logger.tab_param;
    
    v_row  PERIODS_CONF%ROWTYPE;
  BEGIN    
    logger.append_param(v_params, 'COMMAND', pi_command);
    logger.append_param(v_params, 'APP_PAGE', pi_app_page);
    
    logger.log('START', v_scope, null, v_params);
    p_get_apex_items(pi_app_page, v_row);
                      
    v_return_message := f_PERIODS_CONF(
                                    pi_command => pi_command,
                                    pi_row => v_row
                                    );
    

    apex_util_pkg.p_show_message ( pi_message  => v_return_message );

    logger.log('STOP', v_scope);
    
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;
  END p_PERIODS_CONF;
  
--------------------------------------------------------------------------------

  function f_PERIODS_CONF(
    pi_command IN CONST_PKG.t_code,
    pi_row IN PERIODS_CONF%ROWTYPE
  ) return CALL_RESULT 
  IS
    v_command CONST_PKG.t_code := f_prepareString(pi_command);
    v_return_message CALL_RESULT;
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_PERIODS_CONF';
    v_params logger.tab_param;
    
  BEGIN    
    logger.append_param(v_params, 'COMMAND', pi_command);
    logger.append_param(v_params, 'PERIODS_CONF_CODE', pi_row.CODE);
    
    logger.log('START', v_scope, null, v_params);
                      
    
    IF f_check_parameters('f_PERIODS_CONF', v_command) THEN
      CASE v_command
        WHEN CONST_PKG.C_COMMAND_INSERT THEN v_return_message := f_PERIODS_CONF_insert(pi_row);
        WHEN CONST_PKG.C_COMMAND_UPDATE THEN v_return_message := f_PERIODS_CONF_update(pi_row);
        WHEN CONST_PKG.C_COMMAND_DELETE THEN v_return_message := f_PERIODS_CONF_delete(pi_row);
        WHEN CONST_PKG.C_COMMAND_COPY THEN v_return_message := f_PERIODS_CONF_copy(pi_row);
      END CASE;
    else
      v_return_message := HANDLE_PKG.err_message( apex_util_pkg.f_lang('TAPI_WRONG_COMMAND_ERROR') , v_scope);
    end if;
    
    logger.log('STOP', v_scope);
    
    return v_return_message;
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;    
  END f_PERIODS_CONF;

--------------------------------------------------------------------------------
  procedure p_get_PERIODS_CONF(
      pi_app_page IN NUMBER default v('APP_PAGE_ID')
    )
  as
    v_scope logger_logs.scope%type := gc_scope_prefix || 'p_get_PERIODS_CONF';
    v_params logger.tab_param;
    
    v_row  PERIODS_CONF%ROWTYPE;
  begin
    logger.append_param(v_params, 'pi_app_page', pi_app_page);
    logger.log('START', v_scope, null, v_params);

    p_get_apex_items (
      pi_app_page => pi_app_page,
      pio_row  => v_row
    );
    
    v_row := f_get_PERIODS_CONF(
                  pi_CODE => v_row.CODE
                );
    
    p_set_apex_items(
      pi_app_page => pi_app_page,
      pi_row   => v_row
    );
  
    logger.log('END', v_scope);
  exception
    when others then
      logger.log_error('Unknown error:'||SQLERRM, v_scope, null, v_params);
      raise;
  end p_get_PERIODS_CONF;

--------------------------------------------------------------------------------
  function f_get_PERIODS_CONF(
    pi_CODE IN PERIODS_CONF.CODE%TYPE
  ) return PERIODS_CONF%ROWTYPE
  IS
    v_row          PERIODS_CONF%ROWTYPE;
    
    v_scope logger_logs.scope%type := gc_scope_prefix || 'f_get_PERIODS_CONF' ;
    v_params logger.tab_param;
  BEGIN
    logger.append_param(v_params, 'CODE', pi_CODE);
    
    logger.log('START', v_scope, null, v_params);
    
    
    logger.log('Rozpoczynam pobieranie wiersza', v_scope);
    
    SELECT
      *
    INTO
      v_row
    FROM
      PERIODS_CONF
    WHERE 1 = 1
      and CODE = pi_CODE
      ;
    logger.log('STOP. Success', v_scope);
    
    return v_row;
    
  EXCEPTION
  WHEN OTHERS THEN
    logger.log_error(CONST_PKG.C_WHEN_OTHERS_MESSAGE, v_scope, null, v_params);
    raise;
  END f_get_PERIODS_CONF;

END PERIODS_CONF_PKG;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('PERIODS_CONF_PKG', 'rgrzegorczyk', 'changelog/4_changelog_replaceable.xml', SYSTIMESTAMP, 27, '8:c2400e9650dd48b3ab1dbbd2c2f13337', 'sqlFile; sqlFile', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/5_changelog_dml.xml::insert_periods_conf::RGRZEGORCZYK
-- Insert into periods table
truncate table PERIODS_CONF;

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.01','January 2021','MONTH',to_date('2021-01-01','YYYY-MM-DD'),to_date('2021-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.02','February 2021','MONTH',to_date('2021-02-01','YYYY-MM-DD'),to_date('2021-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.03','March 2021','MONTH',to_date('2021-03-01','YYYY-MM-DD'),to_date('2021-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.04','April 2021','MONTH',to_date('2021-04-01','YYYY-MM-DD'),to_date('2021-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.05','May 2021','MONTH',to_date('2021-05-01','YYYY-MM-DD'),to_date('2021-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.06','June 2021','MONTH',to_date('2021-06-01','YYYY-MM-DD'),to_date('2021-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.07','July 2021','MONTH',to_date('2021-07-01','YYYY-MM-DD'),to_date('2021-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.08','August 2021','MONTH',to_date('2021-08-01','YYYY-MM-DD'),to_date('2021-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.09','September 2021','MONTH',to_date('2021-09-01','YYYY-MM-DD'),to_date('2021-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.10','October 2021','MONTH',to_date('2021-10-01','YYYY-MM-DD'),to_date('2021-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.11','November 2021','MONTH',to_date('2021-11-01','YYYY-MM-DD'),to_date('2021-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021.12','December 2021','MONTH',to_date('2021-12-01','YYYY-MM-DD'),to_date('2021-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.01','January 2022','MONTH',to_date('2022-01-01','YYYY-MM-DD'),to_date('2022-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.02','February 2022','MONTH',to_date('2022-02-01','YYYY-MM-DD'),to_date('2022-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.03','March 2022','MONTH',to_date('2022-03-01','YYYY-MM-DD'),to_date('2022-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.04','April 2022','MONTH',to_date('2022-04-01','YYYY-MM-DD'),to_date('2022-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.05','May 2022','MONTH',to_date('2022-05-01','YYYY-MM-DD'),to_date('2022-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.06','June 2022','MONTH',to_date('2022-06-01','YYYY-MM-DD'),to_date('2022-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.07','July 2022','MONTH',to_date('2022-07-01','YYYY-MM-DD'),to_date('2022-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.08','August 2022','MONTH',to_date('2022-08-01','YYYY-MM-DD'),to_date('2022-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.09','September 2022','MONTH',to_date('2022-09-01','YYYY-MM-DD'),to_date('2022-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.10','October 2022','MONTH',to_date('2022-10-01','YYYY-MM-DD'),to_date('2022-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.11','November 2022','MONTH',to_date('2022-11-01','YYYY-MM-DD'),to_date('2022-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022.12','December 2022','MONTH',to_date('2022-12-01','YYYY-MM-DD'),to_date('2022-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.01','January 2023','MONTH',to_date('2023-01-01','YYYY-MM-DD'),to_date('2023-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.02','February 2023','MONTH',to_date('2023-02-01','YYYY-MM-DD'),to_date('2023-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.03','March 2023','MONTH',to_date('2023-03-01','YYYY-MM-DD'),to_date('2023-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.04','April 2023','MONTH',to_date('2023-04-01','YYYY-MM-DD'),to_date('2023-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.05','May 2023','MONTH',to_date('2023-05-01','YYYY-MM-DD'),to_date('2023-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.06','June 2023','MONTH',to_date('2023-06-01','YYYY-MM-DD'),to_date('2023-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.07','July 2023','MONTH',to_date('2023-07-01','YYYY-MM-DD'),to_date('2023-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.08','August 2023','MONTH',to_date('2023-08-01','YYYY-MM-DD'),to_date('2023-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.09','September 2023','MONTH',to_date('2023-09-01','YYYY-MM-DD'),to_date('2023-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.10','October 2023','MONTH',to_date('2023-10-01','YYYY-MM-DD'),to_date('2023-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.11','November 2023','MONTH',to_date('2023-11-01','YYYY-MM-DD'),to_date('2023-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023.12','December 2023','MONTH',to_date('2023-12-01','YYYY-MM-DD'),to_date('2023-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.01','January 2024','MONTH',to_date('2024-01-01','YYYY-MM-DD'),to_date('2024-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.02','February 2024','MONTH',to_date('2024-02-01','YYYY-MM-DD'),to_date('2024-02-29','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.03','March 2024','MONTH',to_date('2024-03-01','YYYY-MM-DD'),to_date('2024-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.04','April 2024','MONTH',to_date('2024-04-01','YYYY-MM-DD'),to_date('2024-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.05','May 2024','MONTH',to_date('2024-05-01','YYYY-MM-DD'),to_date('2024-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.06','June 2024','MONTH',to_date('2024-06-01','YYYY-MM-DD'),to_date('2024-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.07','July 2024','MONTH',to_date('2024-07-01','YYYY-MM-DD'),to_date('2024-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.08','August 2024','MONTH',to_date('2024-08-01','YYYY-MM-DD'),to_date('2024-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.09','September 2024','MONTH',to_date('2024-09-01','YYYY-MM-DD'),to_date('2024-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.10','October 2024','MONTH',to_date('2024-10-01','YYYY-MM-DD'),to_date('2024-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.11','November 2024','MONTH',to_date('2024-11-01','YYYY-MM-DD'),to_date('2024-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024.12','December 2024','MONTH',to_date('2024-12-01','YYYY-MM-DD'),to_date('2024-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.01','January 2025','MONTH',to_date('2025-01-01','YYYY-MM-DD'),to_date('2025-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.02','February 2025','MONTH',to_date('2025-02-01','YYYY-MM-DD'),to_date('2025-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.03','March 2025','MONTH',to_date('2025-03-01','YYYY-MM-DD'),to_date('2025-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.04','April 2025','MONTH',to_date('2025-04-01','YYYY-MM-DD'),to_date('2025-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.05','May 2025','MONTH',to_date('2025-05-01','YYYY-MM-DD'),to_date('2025-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.06','June 2025','MONTH',to_date('2025-06-01','YYYY-MM-DD'),to_date('2025-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.07','July 2025','MONTH',to_date('2025-07-01','YYYY-MM-DD'),to_date('2025-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.08','August 2025','MONTH',to_date('2025-08-01','YYYY-MM-DD'),to_date('2025-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.09','September 2025','MONTH',to_date('2025-09-01','YYYY-MM-DD'),to_date('2025-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.10','October 2025','MONTH',to_date('2025-10-01','YYYY-MM-DD'),to_date('2025-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.11','November 2025','MONTH',to_date('2025-11-01','YYYY-MM-DD'),to_date('2025-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025.12','December 2025','MONTH',to_date('2025-12-01','YYYY-MM-DD'),to_date('2025-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.01','January 2026','MONTH',to_date('2026-01-01','YYYY-MM-DD'),to_date('2026-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.02','February 2026','MONTH',to_date('2026-02-01','YYYY-MM-DD'),to_date('2026-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.03','March 2026','MONTH',to_date('2026-03-01','YYYY-MM-DD'),to_date('2026-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.04','April 2026','MONTH',to_date('2026-04-01','YYYY-MM-DD'),to_date('2026-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.05','May 2026','MONTH',to_date('2026-05-01','YYYY-MM-DD'),to_date('2026-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.06','June 2026','MONTH',to_date('2026-06-01','YYYY-MM-DD'),to_date('2026-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.07','July 2026','MONTH',to_date('2026-07-01','YYYY-MM-DD'),to_date('2026-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.08','August 2026','MONTH',to_date('2026-08-01','YYYY-MM-DD'),to_date('2026-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.09','September 2026','MONTH',to_date('2026-09-01','YYYY-MM-DD'),to_date('2026-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.10','October 2026','MONTH',to_date('2026-10-01','YYYY-MM-DD'),to_date('2026-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.11','November 2026','MONTH',to_date('2026-11-01','YYYY-MM-DD'),to_date('2026-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026.12','December 2026','MONTH',to_date('2026-12-01','YYYY-MM-DD'),to_date('2026-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.01','January 2027','MONTH',to_date('2027-01-01','YYYY-MM-DD'),to_date('2027-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.02','February 2027','MONTH',to_date('2027-02-01','YYYY-MM-DD'),to_date('2027-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.03','March 2027','MONTH',to_date('2027-03-01','YYYY-MM-DD'),to_date('2027-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.04','April 2027','MONTH',to_date('2027-04-01','YYYY-MM-DD'),to_date('2027-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.05','May 2027','MONTH',to_date('2027-05-01','YYYY-MM-DD'),to_date('2027-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.06','June 2027','MONTH',to_date('2027-06-01','YYYY-MM-DD'),to_date('2027-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.07','July 2027','MONTH',to_date('2027-07-01','YYYY-MM-DD'),to_date('2027-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.08','August 2027','MONTH',to_date('2027-08-01','YYYY-MM-DD'),to_date('2027-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.09','September 2027','MONTH',to_date('2027-09-01','YYYY-MM-DD'),to_date('2027-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.10','October 2027','MONTH',to_date('2027-10-01','YYYY-MM-DD'),to_date('2027-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.11','November 2027','MONTH',to_date('2027-11-01','YYYY-MM-DD'),to_date('2027-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027.12','December 2027','MONTH',to_date('2027-12-01','YYYY-MM-DD'),to_date('2027-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.01','January 2028','MONTH',to_date('2028-01-01','YYYY-MM-DD'),to_date('2028-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.02','February 2028','MONTH',to_date('2028-02-01','YYYY-MM-DD'),to_date('2028-02-29','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.03','March 2028','MONTH',to_date('2028-03-01','YYYY-MM-DD'),to_date('2028-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.04','April 2028','MONTH',to_date('2028-04-01','YYYY-MM-DD'),to_date('2028-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.05','May 2028','MONTH',to_date('2028-05-01','YYYY-MM-DD'),to_date('2028-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.06','June 2028','MONTH',to_date('2028-06-01','YYYY-MM-DD'),to_date('2028-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.07','July 2028','MONTH',to_date('2028-07-01','YYYY-MM-DD'),to_date('2028-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.08','August 2028','MONTH',to_date('2028-08-01','YYYY-MM-DD'),to_date('2028-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.09','September 2028','MONTH',to_date('2028-09-01','YYYY-MM-DD'),to_date('2028-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.10','October 2028','MONTH',to_date('2028-10-01','YYYY-MM-DD'),to_date('2028-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.11','November 2028','MONTH',to_date('2028-11-01','YYYY-MM-DD'),to_date('2028-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028.12','December 2028','MONTH',to_date('2028-12-01','YYYY-MM-DD'),to_date('2028-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.01','January 2029','MONTH',to_date('2029-01-01','YYYY-MM-DD'),to_date('2029-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.02','February 2029','MONTH',to_date('2029-02-01','YYYY-MM-DD'),to_date('2029-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.03','March 2029','MONTH',to_date('2029-03-01','YYYY-MM-DD'),to_date('2029-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.04','April 2029','MONTH',to_date('2029-04-01','YYYY-MM-DD'),to_date('2029-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.05','May 2029','MONTH',to_date('2029-05-01','YYYY-MM-DD'),to_date('2029-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.06','June 2029','MONTH',to_date('2029-06-01','YYYY-MM-DD'),to_date('2029-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.07','July 2029','MONTH',to_date('2029-07-01','YYYY-MM-DD'),to_date('2029-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.08','August 2029','MONTH',to_date('2029-08-01','YYYY-MM-DD'),to_date('2029-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.09','September 2029','MONTH',to_date('2029-09-01','YYYY-MM-DD'),to_date('2029-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.10','October 2029','MONTH',to_date('2029-10-01','YYYY-MM-DD'),to_date('2029-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.11','November 2029','MONTH',to_date('2029-11-01','YYYY-MM-DD'),to_date('2029-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029.12','December 2029','MONTH',to_date('2029-12-01','YYYY-MM-DD'),to_date('2029-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.01','January 2030','MONTH',to_date('2030-01-01','YYYY-MM-DD'),to_date('2030-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.02','February 2030','MONTH',to_date('2030-02-01','YYYY-MM-DD'),to_date('2030-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.03','March 2030','MONTH',to_date('2030-03-01','YYYY-MM-DD'),to_date('2030-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.04','April 2030','MONTH',to_date('2030-04-01','YYYY-MM-DD'),to_date('2030-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.05','May 2030','MONTH',to_date('2030-05-01','YYYY-MM-DD'),to_date('2030-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.06','June 2030','MONTH',to_date('2030-06-01','YYYY-MM-DD'),to_date('2030-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.07','July 2030','MONTH',to_date('2030-07-01','YYYY-MM-DD'),to_date('2030-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.08','August 2030','MONTH',to_date('2030-08-01','YYYY-MM-DD'),to_date('2030-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.09','September 2030','MONTH',to_date('2030-09-01','YYYY-MM-DD'),to_date('2030-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.10','October 2030','MONTH',to_date('2030-10-01','YYYY-MM-DD'),to_date('2030-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.11','November 2030','MONTH',to_date('2030-11-01','YYYY-MM-DD'),to_date('2030-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030.12','December 2030','MONTH',to_date('2030-12-01','YYYY-MM-DD'),to_date('2030-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.01','January 2031','MONTH',to_date('2031-01-01','YYYY-MM-DD'),to_date('2031-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.02','February 2031','MONTH',to_date('2031-02-01','YYYY-MM-DD'),to_date('2031-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.03','March 2031','MONTH',to_date('2031-03-01','YYYY-MM-DD'),to_date('2031-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.04','April 2031','MONTH',to_date('2031-04-01','YYYY-MM-DD'),to_date('2031-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.05','May 2031','MONTH',to_date('2031-05-01','YYYY-MM-DD'),to_date('2031-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.06','June 2031','MONTH',to_date('2031-06-01','YYYY-MM-DD'),to_date('2031-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.07','July 2031','MONTH',to_date('2031-07-01','YYYY-MM-DD'),to_date('2031-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.08','August 2031','MONTH',to_date('2031-08-01','YYYY-MM-DD'),to_date('2031-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.09','September 2031','MONTH',to_date('2031-09-01','YYYY-MM-DD'),to_date('2031-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.10','October 2031','MONTH',to_date('2031-10-01','YYYY-MM-DD'),to_date('2031-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.11','November 2031','MONTH',to_date('2031-11-01','YYYY-MM-DD'),to_date('2031-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2031.12','December 2031','MONTH',to_date('2031-12-01','YYYY-MM-DD'),to_date('2031-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.01','January 2032','MONTH',to_date('2032-01-01','YYYY-MM-DD'),to_date('2032-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.02','February 2032','MONTH',to_date('2032-02-01','YYYY-MM-DD'),to_date('2032-02-29','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.03','March 2032','MONTH',to_date('2032-03-01','YYYY-MM-DD'),to_date('2032-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.04','April 2032','MONTH',to_date('2032-04-01','YYYY-MM-DD'),to_date('2032-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.05','May 2032','MONTH',to_date('2032-05-01','YYYY-MM-DD'),to_date('2032-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.06','June 2032','MONTH',to_date('2032-06-01','YYYY-MM-DD'),to_date('2032-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.07','July 2032','MONTH',to_date('2032-07-01','YYYY-MM-DD'),to_date('2032-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.08','August 2032','MONTH',to_date('2032-08-01','YYYY-MM-DD'),to_date('2032-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.09','September 2032','MONTH',to_date('2032-09-01','YYYY-MM-DD'),to_date('2032-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.10','October 2032','MONTH',to_date('2032-10-01','YYYY-MM-DD'),to_date('2032-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.11','November 2032','MONTH',to_date('2032-11-01','YYYY-MM-DD'),to_date('2032-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2032.12','December 2032','MONTH',to_date('2032-12-01','YYYY-MM-DD'),to_date('2032-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.01','January 2033','MONTH',to_date('2033-01-01','YYYY-MM-DD'),to_date('2033-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.02','February 2033','MONTH',to_date('2033-02-01','YYYY-MM-DD'),to_date('2033-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.03','March 2033','MONTH',to_date('2033-03-01','YYYY-MM-DD'),to_date('2033-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.04','April 2033','MONTH',to_date('2033-04-01','YYYY-MM-DD'),to_date('2033-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.05','May 2033','MONTH',to_date('2033-05-01','YYYY-MM-DD'),to_date('2033-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.06','June 2033','MONTH',to_date('2033-06-01','YYYY-MM-DD'),to_date('2033-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.07','July 2033','MONTH',to_date('2033-07-01','YYYY-MM-DD'),to_date('2033-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.08','August 2033','MONTH',to_date('2033-08-01','YYYY-MM-DD'),to_date('2033-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.09','September 2033','MONTH',to_date('2033-09-01','YYYY-MM-DD'),to_date('2033-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.10','October 2033','MONTH',to_date('2033-10-01','YYYY-MM-DD'),to_date('2033-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.11','November 2033','MONTH',to_date('2033-11-01','YYYY-MM-DD'),to_date('2033-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2033.12','December 2033','MONTH',to_date('2033-12-01','YYYY-MM-DD'),to_date('2033-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.01','January 2034','MONTH',to_date('2034-01-01','YYYY-MM-DD'),to_date('2034-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.02','February 2034','MONTH',to_date('2034-02-01','YYYY-MM-DD'),to_date('2034-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.03','March 2034','MONTH',to_date('2034-03-01','YYYY-MM-DD'),to_date('2034-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.04','April 2034','MONTH',to_date('2034-04-01','YYYY-MM-DD'),to_date('2034-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.05','May 2034','MONTH',to_date('2034-05-01','YYYY-MM-DD'),to_date('2034-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.06','June 2034','MONTH',to_date('2034-06-01','YYYY-MM-DD'),to_date('2034-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.07','July 2034','MONTH',to_date('2034-07-01','YYYY-MM-DD'),to_date('2034-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.08','August 2034','MONTH',to_date('2034-08-01','YYYY-MM-DD'),to_date('2034-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.09','September 2034','MONTH',to_date('2034-09-01','YYYY-MM-DD'),to_date('2034-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.10','October 2034','MONTH',to_date('2034-10-01','YYYY-MM-DD'),to_date('2034-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.11','November 2034','MONTH',to_date('2034-11-01','YYYY-MM-DD'),to_date('2034-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2034.12','December 2034','MONTH',to_date('2034-12-01','YYYY-MM-DD'),to_date('2034-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.01','January 2035','MONTH',to_date('2035-01-01','YYYY-MM-DD'),to_date('2035-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.02','February 2035','MONTH',to_date('2035-02-01','YYYY-MM-DD'),to_date('2035-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.03','March 2035','MONTH',to_date('2035-03-01','YYYY-MM-DD'),to_date('2035-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.04','April 2035','MONTH',to_date('2035-04-01','YYYY-MM-DD'),to_date('2035-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.05','May 2035','MONTH',to_date('2035-05-01','YYYY-MM-DD'),to_date('2035-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.06','June 2035','MONTH',to_date('2035-06-01','YYYY-MM-DD'),to_date('2035-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.07','July 2035','MONTH',to_date('2035-07-01','YYYY-MM-DD'),to_date('2035-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.08','August 2035','MONTH',to_date('2035-08-01','YYYY-MM-DD'),to_date('2035-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.09','September 2035','MONTH',to_date('2035-09-01','YYYY-MM-DD'),to_date('2035-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.10','October 2035','MONTH',to_date('2035-10-01','YYYY-MM-DD'),to_date('2035-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.11','November 2035','MONTH',to_date('2035-11-01','YYYY-MM-DD'),to_date('2035-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2035.12','December 2035','MONTH',to_date('2035-12-01','YYYY-MM-DD'),to_date('2035-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.01','January 2036','MONTH',to_date('2036-01-01','YYYY-MM-DD'),to_date('2036-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.02','February 2036','MONTH',to_date('2036-02-01','YYYY-MM-DD'),to_date('2036-02-29','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.03','March 2036','MONTH',to_date('2036-03-01','YYYY-MM-DD'),to_date('2036-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.04','April 2036','MONTH',to_date('2036-04-01','YYYY-MM-DD'),to_date('2036-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.05','May 2036','MONTH',to_date('2036-05-01','YYYY-MM-DD'),to_date('2036-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.06','June 2036','MONTH',to_date('2036-06-01','YYYY-MM-DD'),to_date('2036-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.07','July 2036','MONTH',to_date('2036-07-01','YYYY-MM-DD'),to_date('2036-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.08','August 2036','MONTH',to_date('2036-08-01','YYYY-MM-DD'),to_date('2036-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.09','September 2036','MONTH',to_date('2036-09-01','YYYY-MM-DD'),to_date('2036-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.10','October 2036','MONTH',to_date('2036-10-01','YYYY-MM-DD'),to_date('2036-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.11','November 2036','MONTH',to_date('2036-11-01','YYYY-MM-DD'),to_date('2036-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2036.12','December 2036','MONTH',to_date('2036-12-01','YYYY-MM-DD'),to_date('2036-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.01','January 2037','MONTH',to_date('2037-01-01','YYYY-MM-DD'),to_date('2037-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.02','February 2037','MONTH',to_date('2037-02-01','YYYY-MM-DD'),to_date('2037-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.03','March 2037','MONTH',to_date('2037-03-01','YYYY-MM-DD'),to_date('2037-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.04','April 2037','MONTH',to_date('2037-04-01','YYYY-MM-DD'),to_date('2037-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.05','May 2037','MONTH',to_date('2037-05-01','YYYY-MM-DD'),to_date('2037-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.06','June 2037','MONTH',to_date('2037-06-01','YYYY-MM-DD'),to_date('2037-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.07','July 2037','MONTH',to_date('2037-07-01','YYYY-MM-DD'),to_date('2037-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.08','August 2037','MONTH',to_date('2037-08-01','YYYY-MM-DD'),to_date('2037-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.09','September 2037','MONTH',to_date('2037-09-01','YYYY-MM-DD'),to_date('2037-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.10','October 2037','MONTH',to_date('2037-10-01','YYYY-MM-DD'),to_date('2037-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.11','November 2037','MONTH',to_date('2037-11-01','YYYY-MM-DD'),to_date('2037-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2037.12','December 2037','MONTH',to_date('2037-12-01','YYYY-MM-DD'),to_date('2037-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.01','January 2038','MONTH',to_date('2038-01-01','YYYY-MM-DD'),to_date('2038-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.02','February 2038','MONTH',to_date('2038-02-01','YYYY-MM-DD'),to_date('2038-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.03','March 2038','MONTH',to_date('2038-03-01','YYYY-MM-DD'),to_date('2038-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.04','April 2038','MONTH',to_date('2038-04-01','YYYY-MM-DD'),to_date('2038-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.05','May 2038','MONTH',to_date('2038-05-01','YYYY-MM-DD'),to_date('2038-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.06','June 2038','MONTH',to_date('2038-06-01','YYYY-MM-DD'),to_date('2038-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.07','July 2038','MONTH',to_date('2038-07-01','YYYY-MM-DD'),to_date('2038-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.08','August 2038','MONTH',to_date('2038-08-01','YYYY-MM-DD'),to_date('2038-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.09','September 2038','MONTH',to_date('2038-09-01','YYYY-MM-DD'),to_date('2038-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.10','October 2038','MONTH',to_date('2038-10-01','YYYY-MM-DD'),to_date('2038-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.11','November 2038','MONTH',to_date('2038-11-01','YYYY-MM-DD'),to_date('2038-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2038.12','December 2038','MONTH',to_date('2038-12-01','YYYY-MM-DD'),to_date('2038-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.01','January 2039','MONTH',to_date('2039-01-01','YYYY-MM-DD'),to_date('2039-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.02','February 2039','MONTH',to_date('2039-02-01','YYYY-MM-DD'),to_date('2039-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.03','March 2039','MONTH',to_date('2039-03-01','YYYY-MM-DD'),to_date('2039-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.04','April 2039','MONTH',to_date('2039-04-01','YYYY-MM-DD'),to_date('2039-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.05','May 2039','MONTH',to_date('2039-05-01','YYYY-MM-DD'),to_date('2039-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.06','June 2039','MONTH',to_date('2039-06-01','YYYY-MM-DD'),to_date('2039-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.07','July 2039','MONTH',to_date('2039-07-01','YYYY-MM-DD'),to_date('2039-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.08','August 2039','MONTH',to_date('2039-08-01','YYYY-MM-DD'),to_date('2039-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.09','September 2039','MONTH',to_date('2039-09-01','YYYY-MM-DD'),to_date('2039-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.10','October 2039','MONTH',to_date('2039-10-01','YYYY-MM-DD'),to_date('2039-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.11','November 2039','MONTH',to_date('2039-11-01','YYYY-MM-DD'),to_date('2039-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2039.12','December 2039','MONTH',to_date('2039-12-01','YYYY-MM-DD'),to_date('2039-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.01','January 2040','MONTH',to_date('2040-01-01','YYYY-MM-DD'),to_date('2040-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.02','February 2040','MONTH',to_date('2040-02-01','YYYY-MM-DD'),to_date('2040-02-29','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.03','March 2040','MONTH',to_date('2040-03-01','YYYY-MM-DD'),to_date('2040-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.04','April 2040','MONTH',to_date('2040-04-01','YYYY-MM-DD'),to_date('2040-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.05','May 2040','MONTH',to_date('2040-05-01','YYYY-MM-DD'),to_date('2040-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.06','June 2040','MONTH',to_date('2040-06-01','YYYY-MM-DD'),to_date('2040-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.07','July 2040','MONTH',to_date('2040-07-01','YYYY-MM-DD'),to_date('2040-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.08','August 2040','MONTH',to_date('2040-08-01','YYYY-MM-DD'),to_date('2040-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.09','September 2040','MONTH',to_date('2040-09-01','YYYY-MM-DD'),to_date('2040-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.10','October 2040','MONTH',to_date('2040-10-01','YYYY-MM-DD'),to_date('2040-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.11','November 2040','MONTH',to_date('2040-11-01','YYYY-MM-DD'),to_date('2040-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2040.12','December 2040','MONTH',to_date('2040-12-01','YYYY-MM-DD'),to_date('2040-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.01','January 2041','MONTH',to_date('2041-01-01','YYYY-MM-DD'),to_date('2041-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.02','February 2041','MONTH',to_date('2041-02-01','YYYY-MM-DD'),to_date('2041-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.03','March 2041','MONTH',to_date('2041-03-01','YYYY-MM-DD'),to_date('2041-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.04','April 2041','MONTH',to_date('2041-04-01','YYYY-MM-DD'),to_date('2041-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.05','May 2041','MONTH',to_date('2041-05-01','YYYY-MM-DD'),to_date('2041-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.06','June 2041','MONTH',to_date('2041-06-01','YYYY-MM-DD'),to_date('2041-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.07','July 2041','MONTH',to_date('2041-07-01','YYYY-MM-DD'),to_date('2041-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.08','August 2041','MONTH',to_date('2041-08-01','YYYY-MM-DD'),to_date('2041-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.09','September 2041','MONTH',to_date('2041-09-01','YYYY-MM-DD'),to_date('2041-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.10','October 2041','MONTH',to_date('2041-10-01','YYYY-MM-DD'),to_date('2041-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.11','November 2041','MONTH',to_date('2041-11-01','YYYY-MM-DD'),to_date('2041-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2041.12','December 2041','MONTH',to_date('2041-12-01','YYYY-MM-DD'),to_date('2041-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.01','January 2042','MONTH',to_date('2042-01-01','YYYY-MM-DD'),to_date('2042-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.02','February 2042','MONTH',to_date('2042-02-01','YYYY-MM-DD'),to_date('2042-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.03','March 2042','MONTH',to_date('2042-03-01','YYYY-MM-DD'),to_date('2042-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.04','April 2042','MONTH',to_date('2042-04-01','YYYY-MM-DD'),to_date('2042-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.05','May 2042','MONTH',to_date('2042-05-01','YYYY-MM-DD'),to_date('2042-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.06','June 2042','MONTH',to_date('2042-06-01','YYYY-MM-DD'),to_date('2042-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.07','July 2042','MONTH',to_date('2042-07-01','YYYY-MM-DD'),to_date('2042-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.08','August 2042','MONTH',to_date('2042-08-01','YYYY-MM-DD'),to_date('2042-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.09','September 2042','MONTH',to_date('2042-09-01','YYYY-MM-DD'),to_date('2042-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.10','October 2042','MONTH',to_date('2042-10-01','YYYY-MM-DD'),to_date('2042-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.11','November 2042','MONTH',to_date('2042-11-01','YYYY-MM-DD'),to_date('2042-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2042.12','December 2042','MONTH',to_date('2042-12-01','YYYY-MM-DD'),to_date('2042-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.01','January 2043','MONTH',to_date('2043-01-01','YYYY-MM-DD'),to_date('2043-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.02','February 2043','MONTH',to_date('2043-02-01','YYYY-MM-DD'),to_date('2043-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.03','March 2043','MONTH',to_date('2043-03-01','YYYY-MM-DD'),to_date('2043-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.04','April 2043','MONTH',to_date('2043-04-01','YYYY-MM-DD'),to_date('2043-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.05','May 2043','MONTH',to_date('2043-05-01','YYYY-MM-DD'),to_date('2043-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.06','June 2043','MONTH',to_date('2043-06-01','YYYY-MM-DD'),to_date('2043-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.07','July 2043','MONTH',to_date('2043-07-01','YYYY-MM-DD'),to_date('2043-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.08','August 2043','MONTH',to_date('2043-08-01','YYYY-MM-DD'),to_date('2043-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.09','September 2043','MONTH',to_date('2043-09-01','YYYY-MM-DD'),to_date('2043-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.10','October 2043','MONTH',to_date('2043-10-01','YYYY-MM-DD'),to_date('2043-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.11','November 2043','MONTH',to_date('2043-11-01','YYYY-MM-DD'),to_date('2043-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2043.12','December 2043','MONTH',to_date('2043-12-01','YYYY-MM-DD'),to_date('2043-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.01','January 2044','MONTH',to_date('2044-01-01','YYYY-MM-DD'),to_date('2044-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.02','February 2044','MONTH',to_date('2044-02-01','YYYY-MM-DD'),to_date('2044-02-29','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.03','March 2044','MONTH',to_date('2044-03-01','YYYY-MM-DD'),to_date('2044-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.04','April 2044','MONTH',to_date('2044-04-01','YYYY-MM-DD'),to_date('2044-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.05','May 2044','MONTH',to_date('2044-05-01','YYYY-MM-DD'),to_date('2044-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.06','June 2044','MONTH',to_date('2044-06-01','YYYY-MM-DD'),to_date('2044-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.07','July 2044','MONTH',to_date('2044-07-01','YYYY-MM-DD'),to_date('2044-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.08','August 2044','MONTH',to_date('2044-08-01','YYYY-MM-DD'),to_date('2044-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.09','September 2044','MONTH',to_date('2044-09-01','YYYY-MM-DD'),to_date('2044-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.10','October 2044','MONTH',to_date('2044-10-01','YYYY-MM-DD'),to_date('2044-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.11','November 2044','MONTH',to_date('2044-11-01','YYYY-MM-DD'),to_date('2044-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2044.12','December 2044','MONTH',to_date('2044-12-01','YYYY-MM-DD'),to_date('2044-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.01','January 2045','MONTH',to_date('2045-01-01','YYYY-MM-DD'),to_date('2045-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.02','February 2045','MONTH',to_date('2045-02-01','YYYY-MM-DD'),to_date('2045-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.03','March 2045','MONTH',to_date('2045-03-01','YYYY-MM-DD'),to_date('2045-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.04','April 2045','MONTH',to_date('2045-04-01','YYYY-MM-DD'),to_date('2045-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.05','May 2045','MONTH',to_date('2045-05-01','YYYY-MM-DD'),to_date('2045-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.06','June 2045','MONTH',to_date('2045-06-01','YYYY-MM-DD'),to_date('2045-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.07','July 2045','MONTH',to_date('2045-07-01','YYYY-MM-DD'),to_date('2045-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.08','August 2045','MONTH',to_date('2045-08-01','YYYY-MM-DD'),to_date('2045-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.09','September 2045','MONTH',to_date('2045-09-01','YYYY-MM-DD'),to_date('2045-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.10','October 2045','MONTH',to_date('2045-10-01','YYYY-MM-DD'),to_date('2045-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.11','November 2045','MONTH',to_date('2045-11-01','YYYY-MM-DD'),to_date('2045-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2045.12','December 2045','MONTH',to_date('2045-12-01','YYYY-MM-DD'),to_date('2045-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.01','January 2046','MONTH',to_date('2046-01-01','YYYY-MM-DD'),to_date('2046-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.02','February 2046','MONTH',to_date('2046-02-01','YYYY-MM-DD'),to_date('2046-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.03','March 2046','MONTH',to_date('2046-03-01','YYYY-MM-DD'),to_date('2046-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.04','April 2046','MONTH',to_date('2046-04-01','YYYY-MM-DD'),to_date('2046-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.05','May 2046','MONTH',to_date('2046-05-01','YYYY-MM-DD'),to_date('2046-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.06','June 2046','MONTH',to_date('2046-06-01','YYYY-MM-DD'),to_date('2046-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.07','July 2046','MONTH',to_date('2046-07-01','YYYY-MM-DD'),to_date('2046-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.08','August 2046','MONTH',to_date('2046-08-01','YYYY-MM-DD'),to_date('2046-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.09','September 2046','MONTH',to_date('2046-09-01','YYYY-MM-DD'),to_date('2046-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.10','October 2046','MONTH',to_date('2046-10-01','YYYY-MM-DD'),to_date('2046-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.11','November 2046','MONTH',to_date('2046-11-01','YYYY-MM-DD'),to_date('2046-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2046.12','December 2046','MONTH',to_date('2046-12-01','YYYY-MM-DD'),to_date('2046-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.01','January 2047','MONTH',to_date('2047-01-01','YYYY-MM-DD'),to_date('2047-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.02','February 2047','MONTH',to_date('2047-02-01','YYYY-MM-DD'),to_date('2047-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.03','March 2047','MONTH',to_date('2047-03-01','YYYY-MM-DD'),to_date('2047-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.04','April 2047','MONTH',to_date('2047-04-01','YYYY-MM-DD'),to_date('2047-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.05','May 2047','MONTH',to_date('2047-05-01','YYYY-MM-DD'),to_date('2047-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.06','June 2047','MONTH',to_date('2047-06-01','YYYY-MM-DD'),to_date('2047-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.07','July 2047','MONTH',to_date('2047-07-01','YYYY-MM-DD'),to_date('2047-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.08','August 2047','MONTH',to_date('2047-08-01','YYYY-MM-DD'),to_date('2047-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.09','September 2047','MONTH',to_date('2047-09-01','YYYY-MM-DD'),to_date('2047-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.10','October 2047','MONTH',to_date('2047-10-01','YYYY-MM-DD'),to_date('2047-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.11','November 2047','MONTH',to_date('2047-11-01','YYYY-MM-DD'),to_date('2047-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2047.12','December 2047','MONTH',to_date('2047-12-01','YYYY-MM-DD'),to_date('2047-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.01','January 2048','MONTH',to_date('2048-01-01','YYYY-MM-DD'),to_date('2048-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.02','February 2048','MONTH',to_date('2048-02-01','YYYY-MM-DD'),to_date('2048-02-29','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.03','March 2048','MONTH',to_date('2048-03-01','YYYY-MM-DD'),to_date('2048-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.04','April 2048','MONTH',to_date('2048-04-01','YYYY-MM-DD'),to_date('2048-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.05','May 2048','MONTH',to_date('2048-05-01','YYYY-MM-DD'),to_date('2048-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.06','June 2048','MONTH',to_date('2048-06-01','YYYY-MM-DD'),to_date('2048-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.07','July 2048','MONTH',to_date('2048-07-01','YYYY-MM-DD'),to_date('2048-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.08','August 2048','MONTH',to_date('2048-08-01','YYYY-MM-DD'),to_date('2048-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.09','September 2048','MONTH',to_date('2048-09-01','YYYY-MM-DD'),to_date('2048-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.10','October 2048','MONTH',to_date('2048-10-01','YYYY-MM-DD'),to_date('2048-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.11','November 2048','MONTH',to_date('2048-11-01','YYYY-MM-DD'),to_date('2048-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2048.12','December 2048','MONTH',to_date('2048-12-01','YYYY-MM-DD'),to_date('2048-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.01','January 2049','MONTH',to_date('2049-01-01','YYYY-MM-DD'),to_date('2049-01-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.02','February 2049','MONTH',to_date('2049-02-01','YYYY-MM-DD'),to_date('2049-02-28','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.03','March 2049','MONTH',to_date('2049-03-01','YYYY-MM-DD'),to_date('2049-03-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.04','April 2049','MONTH',to_date('2049-04-01','YYYY-MM-DD'),to_date('2049-04-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.05','May 2049','MONTH',to_date('2049-05-01','YYYY-MM-DD'),to_date('2049-05-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.06','June 2049','MONTH',to_date('2049-06-01','YYYY-MM-DD'),to_date('2049-06-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.07','July 2049','MONTH',to_date('2049-07-01','YYYY-MM-DD'),to_date('2049-07-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.08','August 2049','MONTH',to_date('2049-08-01','YYYY-MM-DD'),to_date('2049-08-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.09','September 2049','MONTH',to_date('2049-09-01','YYYY-MM-DD'),to_date('2049-09-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.10','October 2049','MONTH',to_date('2049-10-01','YYYY-MM-DD'),to_date('2049-10-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.11','November 2049','MONTH',to_date('2049-11-01','YYYY-MM-DD'),to_date('2049-11-30','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2049.12','December 2049','MONTH',to_date('2049-12-01','YYYY-MM-DD'),to_date('2049-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2021','Year 2021','YEAR',to_date('2021-01-01','YYYY-MM-DD'),to_date('2021-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2022','Year 2022','YEAR',to_date('2022-01-01','YYYY-MM-DD'),to_date('2022-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2023','Year 2023','YEAR',to_date('2023-01-01','YYYY-MM-DD'),to_date('2023-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2024','Year 2024','YEAR',to_date('2024-01-01','YYYY-MM-DD'),to_date('2024-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2025','Year 2025','YEAR',to_date('2025-01-01','YYYY-MM-DD'),to_date('2025-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2026','Year 2026','YEAR',to_date('2026-01-01','YYYY-MM-DD'),to_date('2026-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2027','Year 2027','YEAR',to_date('2027-01-01','YYYY-MM-DD'),to_date('2027-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2028','Year 2028','YEAR',to_date('2028-01-01','YYYY-MM-DD'),to_date('2028-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2029','Year 2029','YEAR',to_date('2029-01-01','YYYY-MM-DD'),to_date('2029-12-31','YYYY-MM-DD'));

Insert into PERIODS_CONF (CODE,NAME,TYPE,DATE_FROM,DATE_TO) values ('2030','Year 2030','YEAR',to_date('2030-01-01','YYYY-MM-DD'),to_date('2030-12-31','YYYY-MM-DD'));

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('insert_periods_conf', 'RGRZEGORCZYK', 'changelog/5_changelog_dml.xml', SYSTIMESTAMP, 28, '8:83ea7a93fae9b0a01197436e1dbeef83', 'sqlFile', 'Insert into periods table', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/5_changelog_dml.xml::demo::RGRZEGORCZYK
-- Example data
Insert into EXPENSE_GROUPS (ID,NAME,COMMENTS,CREATED,CREATED_BY,UPDATED,UPDATED_BY) values ('1','Daily spending',null,to_date('2021-06-06','YYYY-MM-DD'),'ADMIN',to_date('2021-06-06','YYYY-MM-DD'),'HOME_BUDGET');

Insert into EXPENSE_TYPES (ID,NAME,COMMENTS,CREATED,CREATED_BY,UPDATED,UPDATED_BY,EXPENSE_GROUP_ID,DISPLAY_ORDER) values ('90','Food and drink',null,to_date('2021-06-06','YYYY-MM-DD'),'ADMIN',to_date('2021-06-06','YYYY-MM-DD'),'HOME_BUDGET','1','1');

Insert into EXPENSES (EXPENSE_TYPES_ID,EXPENSE_DATE,VALUE,IS_RETURNED,RETURN_WIRE_RECEIVED,RETURN_VALUE,COMMENTS,CREATED,CREATED_BY,UPDATED,UPDATED_BY,SHOP_NAME,ORDER_NUMBER,RETURN_DETAILS) values ('90',to_date('2021-01-30','YYYY-MM-DD'),'13.95','N','N',null,null,to_date('2021-06-06','YYYY-MM-DD'),'HOME_BUDGET',to_date('2021-06-06','YYYY-MM-DD'),'HOME_BUDGET',null,null,null);

Insert into EXPENSES (EXPENSE_TYPES_ID,EXPENSE_DATE,VALUE,IS_RETURNED,RETURN_WIRE_RECEIVED,RETURN_VALUE,COMMENTS,CREATED,CREATED_BY,UPDATED,UPDATED_BY,SHOP_NAME,ORDER_NUMBER,RETURN_DETAILS) values ('90',to_date('2021-02-04','YYYY-MM-DD'),'4.39','N','N',null,null,to_date('2021-06-06','YYYY-MM-DD'),'HOME_BUDGET',to_date('2021-06-06','YYYY-MM-DD'),'HOME_BUDGET',null,null,null);

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('demo', 'RGRZEGORCZYK', 'changelog/5_changelog_dml.xml', SYSTIMESTAMP, 29, '8:c7b6a31c2b653d5146b4a31736b558e3', 'sqlFile', 'Example data', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Changeset changelog/6_changelog_end.xml::compile_schema::RGRZEGORCZYK
begin 
  	  	dbms_utility.compile_schema(
  schema        => user ,
  compile_all   =>TRUE,
  reuse_settings =>TRUE);
end;
/

INSERT INTO HOME_BUDGET.DATABASECHANGELOG (ID, AUTHOR, FILENAME, DATEEXECUTED, ORDEREXECUTED, MD5SUM, DESCRIPTION, COMMENTS, EXECTYPE, CONTEXTS, LABELS, LIQUIBASE, DEPLOYMENT_ID) VALUES ('compile_schema', 'RGRZEGORCZYK', 'changelog/6_changelog_end.xml', SYSTIMESTAMP, 30, '8:44126af414082af64465f2eb90886579', 'sqlFile', '', 'EXECUTED', NULL, NULL, '4.4.2', '1786195576');

-- Release Database Lock
UPDATE HOME_BUDGET.DATABASECHANGELOGLOCK SET LOCKED = 0, LOCKEDBY = NULL, LOCKGRANTED = NULL WHERE ID = 1;

